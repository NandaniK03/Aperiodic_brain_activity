%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}

\graphicspath{ {./_video_thumbnail/}{./} }
\newcommand{\sphinxcontribyoutube}[3]{\begin{quote}\begin{center}\fbox{\url{#1#2#3}}\end{center}\end{quote}}


\title{Analysis of Sleep EEG Data}
\date{Jul 28, 2023}
\release{0.1}
\author{Nandani Kundal}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introduction}
\label{\detokenize{introduction:introduction}}\label{\detokenize{introduction::doc}}
\sphinxAtStartPar
During my 2023 summer internship at NIMHANS, I explored computational analysis of sleep EEG. The objective was to investigate the trend of aperiodic brain activity across different sleep stages in meditators using the FOOOF algorithm.
\begin{quote}

\sphinxAtStartPar
Background:
\end{quote}

\sphinxAtStartPar
Electroencephalography (EEG) has long been utilized as a valuable tool in sleep research, providing valuable insights into brain activity during various stages of sleep. Traditional EEG analyses have predominantly focused on canonically defined frequency bands, potentially overlooking the aperiodic (1/f\sphinxhyphen{}like) component of brain activity. However, recent advancements in computational neuroscience have opened new avenues to investigate the underlying complexities of sleep EEG data.
\begin{quote}

\sphinxAtStartPar
Project Objectives:
\end{quote}

\sphinxAtStartPar
My internship aimed to investigate the aperiodic component of sleep EEG data across different sleep stages . Aperiodic brain activity, characterized by its power\sphinxhyphen{}law scaling, has been gaining attention as it may hold essential clues about brain network dynamics and cognitive processes.
\begin{quote}

\sphinxAtStartPar
Methodology:
\end{quote}

\sphinxAtStartPar
To achieve the project goals, I employed the FOOOF (Fitting Oscillations and One\sphinxhyphen{}Over F) algorithm, a powerful computational tool developed to model the power spectrum as a combination of an aperiodic component (1/f slope) and periodic component (peaks over the 1/f slope). All data processing and analyses were carried out using Python, leveraging its rich ecosystem of libraries for scientific computing and data visualization.
\begin{quote}

\sphinxAtStartPar
Results:
\end{quote}

\sphinxAtStartPar
The computational analyses revealed distinct features of aperiodic brain activity across different sleep stages, enhancing our understanding of brain dynamics during sleep. My work suggests that aperiodic spectral parameters derived from FOOOF analysis of EEG data hold promise as objective measures for characterizing sleep states. Subtle yet significant differences in aperiodic measures were observed between meditators and controls during sleep. Further research could explore the potential influence of meditation practices on sleep physiology and aid in the development of targeted interventions.
\begin{quote}

\sphinxAtStartPar
Conclusion:
\end{quote}

\sphinxAtStartPar
My internship experience at NIMHANS provided me with invaluable exposure to sleep research, computational neuroscience, and data analysis. The exploration of aperiodic brain activity during sleep has the potential to enrich our understanding of the brain’s complex organization and may contribute to future advancements in sleep medicine and cognitive neuroscience.
\begin{quote}

\sphinxAtStartPar
Acknowledgments:
\end{quote}

\sphinxAtStartPar
I express my sincere gratitude to my mentors and researchers at NIMHANS for their guidance, encouragement, and support throughout this internship. Their expertise and insights have been instrumental in shaping the course of my work.


\chapter{Data and Methods}
\label{\detokenize{data_method:data-and-methods}}\label{\detokenize{data_method::doc}}\begin{quote}

\sphinxAtStartPar
Data
\end{quote}

\sphinxAtStartPar
The dataset utilized in this study comprises sleep records (EEG signals recorded from an entire night of undisturbed sleep) obtained from {[}source/acquisition method{]}.
The dataset includes EEG data collected from 45 healthy subjects,24 meditating subjects and 21 non\sphinxhyphen{}meditating subjects, all falling within the age range of 19 to 74. Subjects were divided into two groups\sphinxhyphen{} Meditators and Controls.
For EEG recordings, the standard 10\sphinxhyphen{}20 electrode placement system was adopted, utilizing 19 channels (Fp1, Fp2, F3, F4, C3, C4, P3, P4, O1, O2, F7, F8, T3, T4, Fz, Cz, Pz, A1, A2) for analysis. Data was filtered in the 1\sphinxhyphen{}40 Hz frequency range with a sampling frequency of 500 Hz. Epoch length was set to 30 seconds.
\begin{quote}

\sphinxAtStartPar
Methods
\end{quote}

\sphinxAtStartPar
The EEG signals were segmented using a sliding window approach, where each window spanned 4 seconds with a 2\sphinxhyphen{}second step (ensuring a 50\% overlap) for every channel. Number of samples in each window was four times the sampling frequency, frequency resolution was 0.25 Hz, frequency range was 0\sphinxhyphen{}40 Hz. Power Spectral density was computed using Welch’s Periodogram.

\sphinxAtStartPar
Spectral parameters were derived using the FOOOF (fitting oscillations and one over f) algorithm. It extracts both aperiodic parameters (spectral slope and intercept) and periodic parameters(central frequency, power and bandwidth) from the neural power spectra.

\sphinxAtStartPar
FOOOF algorithm models the neural power spectra as a combination of an aperiodic component (represented by an 1/f slope) and a periodic component(characterized by oscillatory peaks). To achieve this, the algorithm initially aproximates the aperiodic components and subsequently subtracts the 1/f slope from the original spectra. This results into a flattened spectra with exposed peaks.
Next, the algorithm iteratively fits and subtracts Guassian functions from the flattened spectra, removing the identified peaks. The aperiodic component is refitted. Finally, the FOOOF algorithm combines the aperiodic and periodic components.


\chapter{Code Script}
\label{\detokenize{code:code-script}}\label{\detokenize{code::doc}}

\section{General Description}
\label{\detokenize{code:general-description}}
\sphinxAtStartPar
This script aims to compute the aperiodic component from sleep data and explore the findings across different sleep stages.

\sphinxAtStartPar
Steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Load the sleep data and its corresponding hypnogram for all subjects.

\item {} 
\sphinxAtStartPar
Data Cleanup:

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Epoch the data into 30\sphinxhyphen{}second intervals.

\item {} 
\sphinxAtStartPar
Extract the hypnogram as a sequence for every 30 seconds to align it with the sleep data.

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Power Spectral Density (PSD) Computation:

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
For each channel, compute the Power Spectral Density (PSD) using Welch’s method with a median of the 4\sphinxhyphen{}second 50\% overlap Fast Fourier Transforms (FFTs).

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
Fit Aperiodic Components:

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Apply the FOOOF algorithm for each 30\sphinxhyphen{}second epoch of the PSD data.

\item {} 
\sphinxAtStartPar
Save the results of the FOOOF analysis for the aperiodic and periodic parameters.

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
\sphinxAtStartPar
Sleep Stage Averaging:

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Average the aperiodic parameters across N1, N2, N3, and R sleep stages for each channel.

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
\sphinxAtStartPar
Data Aggregation:

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Save the averaged aperiodic parameters to a dataframe for further analysis.

\end{itemize}

\sphinxAtStartPar
Note:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Ensure that the input sleep data and hypnogram files are in the correct format and structure for proper data processing.

\item {} 
\sphinxAtStartPar
The script uses FOOOF and PSD to analyze sleep data. Please refer to the respective papers and documentation for more information.

\item {} 
\sphinxAtStartPar
Error handling and code comments are included in the script to enhance code clarity and maintainability.

\end{itemize}


\section{Code Description}
\label{\detokenize{code:code-description}}

\subsection{1. Load necessary libraries}
\label{\detokenize{code:load-necessary-libraries}}
\sphinxAtStartPar
In this code block, we start by loading several essential libraries that will be used throughout the script:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{glob}: This library has been used to load all PSG(Polysomnography) files and corresponding Scored files with .edf extension. It can retrieve the file paths.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{os}: The \sphinxtitleref{os} library provides functions for interacting with operating system. It has been used to perform file\sphinxhyphen{}related operations.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{yasa}: \sphinxtitleref{yasa} has been used for slicing hypnogram into 30\sphinxhyphen{}second windows and creating topoplots for visualization.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{numpy}: It is a fundamental library for working with numerical data in Python.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{matplotlib}: This library is amazing for visualizing data. It has been used to create plots and charts.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{scipy} : welch module from \sphinxtitleref{scipy} has been utilized for computing the welch periodogram to compute the Power Spectral Density(psd) of EEG signal. stats module has been used to take trimmed mean of data.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{seaborn}: \sphinxtitleref{seaborn} provides a high\sphinxhyphen{}level interface for drawing attractive and informative statistical graphs

\item {} 
\sphinxAtStartPar
\sphinxtitleref{mne}: It has been used for reading edf files conatining EEG data

\item {} 
\sphinxAtStartPar
\sphinxtitleref{pandas}: \sphinxtitleref{pandas} is useful for data manipulation and analysis.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{FOOOF}: \sphinxtitleref{FOOOF} has been used for model fitting. FOOOF is a fast, efficient, and physiologically\sphinxhyphen{}informed tool to parameterize neural power spectra.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} Import necessary libraries | Block 0}

\PYG{k+kn}{import} \PYG{n+nn}{glob} \PYG{k}{as} \PYG{n+nn}{gb}
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{yasa}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{signal} \PYG{k+kn}{import} \PYG{n}{welch}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{stats} \PYG{k+kn}{import} \PYG{n}{trim\PYGZus{}mean}
\PYG{k+kn}{import} \PYG{n+nn}{seaborn} \PYG{k}{as} \PYG{n+nn}{sb}
\PYG{k+kn}{import} \PYG{n+nn}{mne}
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{from} \PYG{n+nn}{fooof} \PYG{k+kn}{import} \PYG{n}{FOOOF}
\end{sphinxVerbatim}


\subsection{2. Load files}
\label{\detokenize{code:load-files}}
\sphinxAtStartPar
The code block above deals with loading files, specifically PSG (Polysomnography) and scored files(hypnogram), for further processing and analysis.
\begin{itemize}
\item {} 
\sphinxAtStartPar
First we specify the folder path where PSG files/ Scored files are located

\item {} 
\sphinxAtStartPar
using \sphinxcode{\sphinxupquote{glob}} module. we retrieve a list of files in the specified folder with the extension \sphinxcode{\sphinxupquote{.edf}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{psg\_files\_all}} /  \sphinxcode{\sphinxupquote{scored\_files\_all}} list is by default loaded in the lixographic order. These can be sorted in alphabetical order of filenames using \sphinxcode{\sphinxupquote{sorted()}} function.

\item {} 
\sphinxAtStartPar
List of filenames: We change the current working directory to the folder path where PSG files are located (\sphinxtitleref{folder\_path\_psg}). Using glob, we retrieve a list of PSG files again. The \sphinxcode{\sphinxupquote{psg\_files}} list is sorted to ensure alphabetical ordering of the filenames.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} Load files | Block 1}

\PYG{c+c1}{\PYGZsh{} PSG files}

\PYG{c+c1}{\PYGZsh{} Retrieve a list of files in the folder with a specific extension}
\PYG{c+c1}{\PYGZsh{} Specify the file extension or pattern and the folder path}
\PYG{n}{folder\PYGZus{}path\PYGZus{}psg} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/FOOOF\PYGZus{}data/data}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{file\PYGZus{}pattern\PYGZus{}psg} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*.edf}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} also convert lixographic order to alphabetical order}
\PYG{n}{psg\PYGZus{}files\PYGZus{}all} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{gb}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{n}{folder\PYGZus{}path\PYGZus{}psg} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{file\PYGZus{}pattern\PYGZus{}psg}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Scored files}

\PYG{c+c1}{\PYGZsh{} Retrieve a list of files in the folder with a specific extension}
\PYG{c+c1}{\PYGZsh{} Specify the file extension or pattern and the folder path}
\PYG{n}{folder\PYGZus{}path\PYGZus{}scored} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/FOOOF\PYGZus{}data/metadata}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{file\PYGZus{}pattern\PYGZus{}scored} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*.edf}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} also convert lixographic order to alphabetical order}
\PYG{n}{scored\PYGZus{}files\PYGZus{}all} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{gb}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{n}{folder\PYGZus{}path\PYGZus{}scored} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+}
\PYG{n}{file\PYGZus{}pattern\PYGZus{}scored}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} List containing files names}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{chdir}\PYG{p}{(}\PYG{n}{folder\PYGZus{}path\PYGZus{}psg}\PYG{p}{)}
\PYG{n}{psg\PYGZus{}files} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{gb}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(} \PYG{n}{file\PYGZus{}pattern\PYGZus{}psg}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{3. Load Data}
\label{\detokenize{code:load-data}}
\sphinxAtStartPar
In this code block (Block 2), data loading and processing is performed, including retrieving the 19 required channels along with A1 and A2, filtering the data, and computing the Power Spectral Density (PSD) for each PSG file. Here’s break down of the code:

\sphinxAtStartPar
\sphinxstylestrong{a. Data Loading:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Initialize empty lists \sphinxcode{\sphinxupquote{hypno\_30s\_all}} to store sleep stage labels for each epoch (30s window) and \sphinxcode{\sphinxupquote{psd\_all}} to store PSDs for all PSG files.

\item {} 
\sphinxAtStartPar
For each pair of PSG and scored files obtained from \sphinxcode{\sphinxupquote{zip(psg\_files\_all, scored\_files\_all)}}, we read the PSG data using \sphinxcode{\sphinxupquote{mne.io.read\_raw\_edf}} and store the sampling rate (srate).

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{b. Channel Selection and Bandpass Filtering:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
19 specific channels are to be picked, including A1 and A2, from the PSG data using MNE’s \sphinxcode{\sphinxupquote{pick\_channels}}.

\item {} 
\sphinxAtStartPar
Note that different PSG files may contain different format of labels for electrodes. Eg. Fz electrode could eb labelled as\sphinxhyphen{} ‘Fz’, ‘FZ’, ‘EEG Fz’, ‘EEG Fz’. In the \sphinxcode{\sphinxupquote{channels\_to\_pick}} list, specify these labels in the order from Fp1 to A2.

\item {} 
\sphinxAtStartPar
The data is bandpass filtered between 1 Hz and 40 Hz using \sphinxcode{\sphinxupquote{edfdata.filter}}.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{c. Hypnogram Cleanup:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Read the hypnogram annotations using MNE and convert them to a DataFrame for easier manipulation using \sphinxcode{\sphinxupquote{mne.read\_annotations}} and \textasciigrave{}\textasciigrave{} to\_data\_frame\textasciigrave{}\textasciigrave{}.

\item {} 
\sphinxAtStartPar
The onset column is converted into epoch numbers, representing the start of each epoch in the hypnogram (\sphinxcode{\sphinxupquote{timestamps, only\_time, and epochs\_start}}).

\item {} 
\sphinxAtStartPar
The description column is modified to contain only the sleep stage labels (\sphinxcode{\sphinxupquote{just\_labels}}).

\item {} 
\sphinxAtStartPar
Clean hypnogram is created by repeating each sleep stage label for the duration of the corresponding epoch (\sphinxcode{\sphinxupquote{hypno\_30s}}) for each PSG file. The labels for each PSG file are added to \sphinxcode{\sphinxupquote{hypno\_30s\_all}} in the form of a nested list.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{d. Power Spectra Computation:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
The data is cut into 30\sphinxhyphen{}second epochs using \sphinxcode{\sphinxupquote{yasa.sliding\_window}}.

\item {} 
\sphinxAtStartPar
Ensure that data and hypnogram have the same shape.

\item {} 
\sphinxAtStartPar
The PSD is computed using Welch’s method (\sphinxcode{\sphinxupquote{welch}}) for each 30\sphinxhyphen{}second epoch for every PSG file.

\item {} 
\sphinxAtStartPar
Frequency range is sliced from 0 Hz to 40 Hz for analysis.

\item {} 
\sphinxAtStartPar
The resulting PSDs (for each PSG file) are iteratively stored in the \sphinxcode{\sphinxupquote{psd\_all}} as nested list .

\end{itemize}

\sphinxAtStartPar
By the end of this code block, we will have sleepstage labels and PSDs for each epoch corresponding to individual PSG files (\sphinxtitleref{hypno\_30s\_all\textasciigrave{}}, \sphinxcode{\sphinxupquote{psd\_all}}) both stored as nested lists.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{}  Load the data | Get the 19 channels required + A1 and A2 | Block 2}

\PYG{c+c1}{\PYGZsh{} initialize empty lists to store sleepstage labels ad psds for all PSG files}
\PYG{n}{hypno\PYGZus{}30s\PYGZus{}all} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{psd\PYGZus{}all} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{PSGfiles}\PYG{p}{,} \PYG{n}{scored\PYGZus{}files} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{psg\PYGZus{}files\PYGZus{}all}\PYG{p}{,} \PYG{n}{scored\PYGZus{}files\PYGZus{}all}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{hypno\PYGZus{}30s} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} read psgfile}
    \PYG{n}{edfdata} \PYG{o}{=} \PYG{n}{mne}\PYG{o}{.}\PYG{n}{io}\PYG{o}{.}\PYG{n}{read\PYGZus{}raw\PYGZus{}edf}\PYG{p}{(}\PYG{n}{PSGfiles}\PYG{p}{,} \PYG{n}{preload}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{srate} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{edfdata}\PYG{o}{.}\PYG{n}{info}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sfreq}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Get the 19 channels required + A1 and A2}
    \PYG{n}{channels\PYGZus{}to\PYGZus{}pick} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fp1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FP1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fp2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FP2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                       \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F7}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FZ}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CZ}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Pz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PZ}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

    \PYG{n}{edfdata}\PYG{o}{.}\PYG{n}{pick\PYGZus{}channels}\PYG{p}{(}\PYG{n}{channels\PYGZus{}to\PYGZus{}pick}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} bandpass filter data}
    \PYG{n}{edfdata}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kc}{None}\PYG{p}{,}\PYG{n}{fir\PYGZus{}design}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{firwin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{load\PYGZus{}data}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{edfdata}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{k+kc}{None}\PYG{p}{,}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{n}{fir\PYGZus{}design}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{firwin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{load\PYGZus{}data}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{edfdata}\PYG{o}{.}\PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mf}{1e6} \PYG{c+c1}{\PYGZsh{}coverting volts to microvolts}

\PYG{c+c1}{\PYGZsh{} Cleanup the hypnogram data into a sequence of stages every epoch}
    \PYG{n}{hypnogram} \PYG{o}{=} \PYG{n}{mne}\PYG{o}{.}\PYG{n}{read\PYGZus{}annotations}\PYG{p}{(}\PYG{n}{scored\PYGZus{}files}\PYG{p}{)}
    \PYG{n}{hypnogram\PYGZus{}annot} \PYG{o}{=} \PYG{n}{hypnogram}\PYG{o}{.}\PYG{n}{to\PYGZus{}data\PYGZus{}frame}\PYG{p}{(}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} change the duration column into epochs count}
    \PYG{n}{hypnogram\PYGZus{}annot}\PYG{o}{.}\PYG{n}{duration} \PYG{o}{=} \PYG{n}{hypnogram\PYGZus{}annot}\PYG{o}{.}\PYG{n}{duration}\PYG{o}{/}\PYG{l+m+mi}{30}

    \PYG{c+c1}{\PYGZsh{} convert the onset column to epoch number}
    \PYG{n}{timestamps} \PYG{o}{=} \PYG{n}{hypnogram\PYGZus{}annot}\PYG{o}{.}\PYG{n}{onset}\PYG{o}{.}\PYG{n}{dt}\PYG{o}{.}\PYG{n}{strftime}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZpc{}}\PYG{l+s+s2}{m/}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s2}{/}\PYG{l+s+s2}{\PYGZpc{}}\PYG{l+s+s2}{Y, }\PYG{l+s+s2}{\PYGZpc{}}\PYG{l+s+s2}{H:}\PYG{l+s+s2}{\PYGZpc{}}\PYG{l+s+s2}{M:}\PYG{l+s+s2}{\PYGZpc{}}\PYG{l+s+s2}{S}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{only\PYGZus{}time} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{entries} \PYG{o+ow}{in} \PYG{n}{timestamps}\PYG{p}{:}
        \PYG{n}{times} \PYG{o}{=} \PYG{n}{entries}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{n}{only\PYGZus{}time}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{times}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} converting hour month and seconds as epoch number}
    \PYG{n}{epochs\PYGZus{}start} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{entries} \PYG{o+ow}{in} \PYG{n}{only\PYGZus{}time}\PYG{p}{:}
        \PYG{n}{hh} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{entries}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{120}
        \PYG{n}{mm} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{entries}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2}
        \PYG{n}{ss} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{entries}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/} \PYG{l+m+mi}{30}

        \PYG{n}{epochs\PYGZus{}start}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{hh}\PYG{o}{+}\PYG{n}{mm}\PYG{o}{+}\PYG{n}{ss}\PYG{p}{)}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} replacing the onset column with start of epoch}
    \PYG{n}{hypnogram\PYGZus{}annot}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{onset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{epochs\PYGZus{}start}
    \PYG{n}{epochs\PYGZus{}start} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{entries} \PYG{o+ow}{in} \PYG{n}{only\PYGZus{}time}\PYG{p}{:}
        \PYG{n}{hh} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{entries}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{120}
        \PYG{n}{mm} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{entries}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2}
        \PYG{n}{ss} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{entries}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/} \PYG{l+m+mi}{30}

        \PYG{n}{epochs\PYGZus{}start}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{hh}\PYG{o}{+}\PYG{n}{mm}\PYG{o}{+}\PYG{n}{ss}\PYG{p}{)}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} replacing the onset column with start of epoch}
    \PYG{n}{hypnogram\PYGZus{}annot}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{onset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{epochs\PYGZus{}start}

    \PYG{c+c1}{\PYGZsh{} keep the description column neat}
    \PYG{n}{just\PYGZus{}labels} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{entries} \PYG{o+ow}{in} \PYG{n}{hypnogram\PYGZus{}annot}\PYG{o}{.}\PYG{n}{description}\PYG{p}{:}
        \PYG{n}{just\PYGZus{}labels}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{entries}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} replacing the description column with just\PYGZus{}labels}
    \PYG{n}{hypnogram\PYGZus{}annot}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{description}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{just\PYGZus{}labels}

    \PYG{c+c1}{\PYGZsh{} we need only the duration column and description column to recreate hypnogram}
    \PYG{c+c1}{\PYGZsh{} just reapeat duration times the label in description column}
    \PYG{c+c1}{\PYGZsh{} adding labels for every second of sleep data}
    \PYG{k}{for} \PYG{n}{stages} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{hypnogram\PYGZus{}annot}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{repetitions} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{hypnogram\PYGZus{}annot}\PYG{o}{.}\PYG{n}{duration}\PYG{p}{[}\PYG{n}{stages}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{hypno\PYGZus{}30s}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{hypnogram\PYGZus{}annot}\PYG{o}{.}\PYG{n}{description}\PYG{p}{[}\PYG{n}{stages}\PYG{p}{]}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} append hypno\PYGZus{}30s for each file}
    \PYG{n}{hypno\PYGZus{}30s\PYGZus{}all}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{hypno\PYGZus{}30s}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Power Spectra}

\PYG{c+c1}{\PYGZsh{} Generate 30 seconds PSDs for all channels}
\PYG{c+c1}{\PYGZsh{} cut data into 30 seconds epochs}

    \PYG{c+c1}{\PYGZsh{} cutting data into 30s epochs using sliding\PYGZus{}window() function}
    \PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{n}{data} \PYG{o}{=} \PYG{n}{yasa}\PYG{o}{.}\PYG{n}{sliding\PYGZus{}window}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{srate}\PYG{p}{,} \PYG{n}{window}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Make sure the hypnogram is also same size as data}
    \PYG{c+c1}{\PYGZsh{} This would imply removing last part of scoring string}
    \PYG{n}{hypno\PYGZus{}30s} \PYG{o}{=} \PYG{n}{hypno\PYGZus{}30s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{np}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} compute power spectrum}
    \PYG{n}{win} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{srate}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Window size is set to 4 seconds}
    \PYG{n}{freqs}\PYG{p}{,} \PYG{n}{psd} \PYG{o}{=} \PYG{n}{welch}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}
                    \PYG{n}{srate}\PYG{p}{,}
                    \PYG{n}{nperseg}\PYG{o}{=}\PYG{n}{win}\PYG{p}{,}
                    \PYG{n}{noverlap}\PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{win}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{}50\PYGZpc{} overlapping}
                    \PYG{n}{axis}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Slicing the frequency ranges from 0 Hz until 40 Hz}
    \PYG{n}{index\PYGZus{}40\PYGZus{}hz} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{freqs} \PYG{o}{==} \PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}
    \PYG{n}{psd} \PYG{o}{=} \PYG{n}{psd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{index\PYGZus{}40\PYGZus{}hz}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}
    \PYG{n}{freqs} \PYG{o}{=} \PYG{n}{freqs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{index\PYGZus{}40\PYGZus{}hz}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} append psd for each file}
    \PYG{n}{psd\PYGZus{}all}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{psd}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{4. Assigning PSDs to respective sleepstages}
\label{\detokenize{code:assigning-psds-to-respective-sleepstages}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The power spectral density (PSD) data is organized based on their corresponding sleep stages for each subject. For each subject, we iterate through their PSD data and match it with the sleep stage labels collected earlier in \sphinxcode{\sphinxupquote{hypno\_30s\_all}}.

\item {} 
\sphinxAtStartPar
PSD data is organized into 5 sleepstages\sphinxhyphen{} W, N1, N2, N3, REM for individual subject file(\sphinxcode{\sphinxupquote{psd\_w}}, \sphinxcode{\sphinxupquote{psd\_n1}}, \sphinxcode{\sphinxupquote{psd\_n2}}, \sphinxcode{\sphinxupquote{psd\_n3}}, \sphinxcode{\sphinxupquote{psd\_rem}}).

\item {} 
\sphinxAtStartPar
The arrays, psd\_sub\_w, psd\_sub\_n1, psd\_sub\_n2, psd\_sub\_n3, and psd\_sub\_rem, hold the PSD data corresponding to each epoch, channel, and frequency range for all subjects and their respective sleep stages.

\item {} 
\sphinxAtStartPar
This organization of data facilitates efficient and structured exploration and interpretation of the results across sleep stages.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} psds correspnding to respective sleepstages | Block 3}

\PYG{c+c1}{\PYGZsh{} initialize lists for containing psds for all subjects corresponding to 5 sleep stages}
\PYG{n}{psd\PYGZus{}sub\PYGZus{}n1} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{psd\PYGZus{}sub\PYGZus{}n2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{psd\PYGZus{}sub\PYGZus{}n3} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{psd\PYGZus{}sub\PYGZus{}rem} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{psd}\PYG{p}{,}\PYG{n}{hypno\PYGZus{}30s} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{psd\PYGZus{}all}\PYG{p}{,}\PYG{n}{hypno\PYGZus{}30s\PYGZus{}all}\PYG{p}{)}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} initialize lists for psd for each subject corresponding to sleep stages}
    \PYG{n}{psd\PYGZus{}w} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{psd\PYGZus{}n1} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{psd\PYGZus{}n2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{psd\PYGZus{}n3} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{psd\PYGZus{}rem} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} index by index matching of elements in PSD and hypnos\PYGZus{}30 for individual subject file}
    \PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{sleepstage} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{psd}\PYG{p}{,}\PYG{n}{hypno\PYGZus{}30s}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{sleepstage} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
            \PYG{n}{psd\PYGZus{}w}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
        \PYG{k}{elif} \PYG{n}{sleepstage} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
            \PYG{n}{psd\PYGZus{}rem}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
        \PYG{k}{elif} \PYG{n}{sleepstage} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
            \PYG{n}{psd\PYGZus{}n1}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
        \PYG{k}{elif} \PYG{n}{sleepstage} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
            \PYG{n}{psd\PYGZus{}n2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
        \PYG{k}{elif} \PYG{n}{sleepstage} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
            \PYG{n}{psd\PYGZus{}n3}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} append stagewise psds for each file}
    \PYG{n}{psd\PYGZus{}sub\PYGZus{}w}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{psd\PYGZus{}w}\PYG{p}{)}
    \PYG{n}{psd\PYGZus{}sub\PYGZus{}n1}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{psd\PYGZus{}n1}\PYG{p}{)}
    \PYG{n}{psd\PYGZus{}sub\PYGZus{}n2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{psd\PYGZus{}n2}\PYG{p}{)}
    \PYG{n}{psd\PYGZus{}sub\PYGZus{}n3}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{psd\PYGZus{}n3}\PYG{p}{)}
    \PYG{n}{psd\PYGZus{}sub\PYGZus{}rem}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{psd\PYGZus{}rem}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} arrays of psds[[epochs,channels,freqs]] corresponding to each stage for all subjects}
\PYG{n}{psd\PYGZus{}sub\PYGZus{}w} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{psd\PYGZus{}w}\PYG{p}{)} \PYG{k}{for} \PYG{n}{psd\PYGZus{}w} \PYG{o+ow}{in} \PYG{n}{psd\PYGZus{}sub\PYGZus{}w}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{psd\PYGZus{}sub\PYGZus{}n1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{psd\PYGZus{}n1}\PYG{p}{)} \PYG{k}{for} \PYG{n}{psd\PYGZus{}n1} \PYG{o+ow}{in} \PYG{n}{psd\PYGZus{}sub\PYGZus{}n1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{psd\PYGZus{}sub\PYGZus{}n2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{psd\PYGZus{}n2}\PYG{p}{)} \PYG{k}{for} \PYG{n}{psd\PYGZus{}n2} \PYG{o+ow}{in} \PYG{n}{psd\PYGZus{}sub\PYGZus{}n2}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{psd\PYGZus{}sub\PYGZus{}n3} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{psd\PYGZus{}n3}\PYG{p}{)} \PYG{k}{for} \PYG{n}{psd\PYGZus{}n3} \PYG{o+ow}{in} \PYG{n}{psd\PYGZus{}sub\PYGZus{}n3}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{psd\PYGZus{}sub\PYGZus{}rem} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{psd\PYGZus{}rem}\PYG{p}{)} \PYG{k}{for} \PYG{n}{psd\PYGZus{}rem} \PYG{o+ow}{in} \PYG{n}{psd\PYGZus{}sub\PYGZus{}rem}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{5. Model Fitting: FOOOF}
\label{\detokenize{code:model-fitting-fooof}}
\sphinxAtStartPar
The following blocks use the FOOOF Python library to model and extract the aperiodic and periodic components of the power spectral density (PSD).


\subsubsection{a. Wake sleepstage}
\label{\detokenize{code:a-wake-sleepstage}}
\sphinxAtStartPar
This block computes the FOOOF (Fitting Oscillations and One\sphinxhyphen{}Over F) model on the data corresponding to the “WAKE” sleep stage.

\sphinxAtStartPar
This block performs the following steps:
\begin{enumerate}
\sphinxsetlistlabels{\roman}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Initialize the FOOOF object(\sphinxcode{\sphinxupquote{fm}}):

\end{enumerate}

\sphinxAtStartPar
Initialize once for all sleepstages. Specify parameters for aperiodic mode, minimum peak height, and maximum number of peaks.
\begin{enumerate}
\sphinxsetlistlabels{\roman}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Iterate through each PSG file and corresponding PSD data:

\end{enumerate}

\sphinxAtStartPar
Store filename labels (\sphinxcode{\sphinxupquote{subject\_sub\_w}}) and FOOOF parameters(\sphinxcode{\sphinxupquote{aperiodic\_params\_sub\_w}}, \sphinxcode{\sphinxupquote{periodic\_params\_sub\_w}}) for all subject files. Store additional labels for epoch and channel (\sphinxcode{\sphinxupquote{epoch\_sub\_w}}, \sphinxcode{\sphinxupquote{channel\_sub\_w}}). These lists are initialized in the beginning of the block.
\begin{quote}

\sphinxAtStartPar
Note: A single set of parameters is stored for each channel of individual epochs corresponding to PSD data for each subject file. Set of parameters to be stored: Aperiodic components\sphinxhyphen{} \sphinxstyleemphasis{Exponent, Offset, R\textasciicircum{}2, Error} and Periodic Components\sphinxhyphen{} \sphinxstyleemphasis{no of peaks picked, peak parameters}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\roman}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Fit the FOOOF model(\sphinxcode{\sphinxupquote{fm.fit()}}) to the PSD data and retrieve the results(\sphinxcode{\sphinxupquote{res\_w}}) for each epoch and channel of a single subject’s PSD data.

\item {} 
\sphinxAtStartPar
Store parameters:

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Store epoch (\sphinxcode{\sphinxupquote{epoch\_w}}), channel (\sphinxcode{\sphinxupquote{channel\_w}}) and filename labels (\sphinxcode{\sphinxupquote{subject\_w}}) for each epoch and channel.

\item {} 
\sphinxAtStartPar
Separately store the aperiodic and periodic parameters for each epoch and channel from \sphinxcode{\sphinxupquote{res\_w}}.

\item {} 
\sphinxAtStartPar
These will be iteratively stored in nested list structure to (\sphinxcode{\sphinxupquote{aperiodic\_params\_sub\_w}}, \sphinxcode{\sphinxupquote{periodic\_params\_sub\_w}})

\end{itemize}
\begin{quote}

\sphinxAtStartPar
Note: We encountered epochs where peaks could not be picked. Periodic parameters are not retrieved from the model fit for such epochs. Guassian cannot be fitted for such epochs and the code throws an error. For such cases, n/a values should be assigned to periodic parameters to maintain uniformity of data.
\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Additionally, maximum no of peaks(\sphinxcode{\sphinxupquote{max\_n\_peaks}}) to be picked have been set to a limit of 10. However, no. of peaks picked from the model fit in each epoch may vary. For maintaining uniformity, the rest of the peak parameters are assigned with n/a values.

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{.}%
\setcounter{enumi}{21}
\item {} 
\sphinxAtStartPar
Organize the parameters into separate DataFrames, one for aperiodic parameters and the other for periodic parameters.

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Insert labels for each set of parameters to these dataframes

\item {} 
\sphinxAtStartPar
Note that peak labels need to be added to periodic parameters, a single label for 3 adjacent columns(representing center frequency, peak power and bandwidth)

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\roman}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
\sphinxAtStartPar
Concatenate the DataFrames and compiles the data into a single DataFrame for the “WAKE” sleep stage. Insert an additional sleepstage label as well.

\end{enumerate}
\begin{quote}

\sphinxAtStartPar
Note: The labels explicitely assigned to each set of parameters makes it easy to trace the parameters back to their origin.
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\roman}{enumi}{enumii}{}{.}%
\setcounter{enumi}{6}
\item {} 
\sphinxAtStartPar
Save the final DataFrame to a CSV file for further analysis and interpretation.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} FOOOF | Block 4}

\PYG{c+c1}{\PYGZsh{} by the end of this loop i should have \PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} complete data with \PYGZsq{}none\PYGZsq{} values for non detectable guassians}
\PYG{c+c1}{\PYGZsh{} separted periodic and aperiodic parameters compiled in dfs}
\PYG{c+c1}{\PYGZsh{} a single dataframe for sleepstage parameters}

\PYG{c+c1}{\PYGZsh{} initializing fooof}
\PYG{n}{fm} \PYG{o}{=} \PYG{n}{FOOOF}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fixed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{min\PYGZus{}peak\PYGZus{}height}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{max\PYGZus{}n\PYGZus{}peaks}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} WAKE SLEEPSTAGE}

\PYG{c+c1}{\PYGZsh{} Initialize empty lists to store data}
\PYG{n}{epoch\PYGZus{}sub\PYGZus{}w} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{channel\PYGZus{}sub\PYGZus{}w} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{subject\PYGZus{}sub\PYGZus{}w} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Outer loop}
\PYG{k}{for} \PYG{n}{psd\PYGZus{}w}\PYG{p}{,} \PYG{n}{file} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{psd\PYGZus{}sub\PYGZus{}w}\PYG{p}{,} \PYG{n}{psg\PYGZus{}files}\PYG{p}{)}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} initializing empty lists for storing parameters}
    \PYG{n}{epoch\PYGZus{}w} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{channel\PYGZus{}w} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}w} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{periodic\PYGZus{}params\PYGZus{}w} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{subject\PYGZus{}w} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} Inner loop}
    \PYG{c+c1}{\PYGZsh{} looping over epochs and channel,outcome\PYGZhy{} epoch x channel no of data entries}
    \PYG{c+c1}{\PYGZsh{} for each subject psd}
    \PYG{k}{for} \PYG{n}{epoch} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{n}{psd\PYGZus{}w}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{channel} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{psd\PYGZus{}w}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}

            \PYG{n}{temp\PYGZus{}periodic} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} stores periodic params temporarily}

            \PYG{c+c1}{\PYGZsh{} fitting spectra}
            \PYG{n}{fm}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{freqs}\PYG{p}{,} \PYG{n}{psd\PYGZus{}w}\PYG{p}{[}\PYG{n}{epoch}\PYG{p}{,} \PYG{n}{channel}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}\PYG{p}{)}

            \PYG{c+c1}{\PYGZsh{} get results}
            \PYG{n}{res\PYGZus{}w} \PYG{o}{=} \PYG{n}{fm}\PYG{o}{.}\PYG{n}{get\PYGZus{}results}\PYG{p}{(}\PYG{p}{)}

            \PYG{c+c1}{\PYGZsh{} Labels}
            \PYG{c+c1}{\PYGZsh{} updating epoch x channel vals, filename}
            \PYG{n}{epoch\PYGZus{}w}\PYG{o}{.}\PYG{n}{append} \PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w\PYGZus{}Epoch\PYGZus{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{epoch}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{n}{channel\PYGZus{}w}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Channel\PYGZus{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{channel}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{n}{subject\PYGZus{}w}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{file}\PYG{p}{)}

            \PYG{c+c1}{\PYGZsh{} Aperiodic Component}
            \PYG{c+c1}{\PYGZsh{} append aperiodic vals to a list}
            \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}w}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{res\PYGZus{}w}\PYG{o}{.}\PYG{n}{aperiodic\PYGZus{}params}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
                              \PYG{n}{res\PYGZus{}w}\PYG{o}{.}\PYG{n}{aperiodic\PYGZus{}params}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
                              \PYG{n}{res\PYGZus{}w}\PYG{o}{.}\PYG{n}{r\PYGZus{}squared}\PYG{p}{,}
                              \PYG{n}{res\PYGZus{}w}\PYG{o}{.}\PYG{n}{error}\PYG{p}{]}\PYG{p}{)}

            \PYG{c+c1}{\PYGZsh{} Periodic Component}
            \PYG{c+c1}{\PYGZsh{} editing out data for which peaks can\PYGZsq{}t be picked}
            \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{res\PYGZus{}w}\PYG{o}{.}\PYG{n}{gaussian\PYGZus{}params}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}

                \PYG{c+c1}{\PYGZsh{} n/a vals for periodic params in this case}
                \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                    \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{temp\PYGZus{}periodic}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{nan}\PYG{p}{)}

                \PYG{n}{periodic\PYGZus{}params\PYGZus{}w}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{temp\PYGZus{}periodic}\PYG{p}{)}

            \PYG{k}{else}\PYG{p}{:}

                \PYG{c+c1}{\PYGZsh{} accessing the nested lists within peak\PYGZus{}params list gives the no of peaks detected}
                \PYG{n}{no\PYGZus{}of\PYGZus{}peaks} \PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{n}{res\PYGZus{}w}\PYG{o}{.}\PYG{n}{peak\PYGZus{}params}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

                \PYG{c+c1}{\PYGZsh{} appending peak vals and n/a vals to fill for empty peak vals}
                \PYG{k}{for} \PYG{n}{peak} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{no\PYGZus{}of\PYGZus{}peaks}\PYG{p}{)}\PYG{p}{:}
                    \PYG{n}{peak\PYGZus{}pack} \PYG{o}{=} \PYG{n}{res\PYGZus{}w}\PYG{o}{.}\PYG{n}{peak\PYGZus{}params}\PYG{p}{[}\PYG{n}{peak}\PYG{p}{]}
                    \PYG{k}{for} \PYG{n}{items} \PYG{o+ow}{in} \PYG{n}{peak\PYGZus{}pack}\PYG{p}{:}
                        \PYG{n}{temp\PYGZus{}periodic}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{items}\PYG{p}{)}

                \PYG{c+c1}{\PYGZsh{} using throw away variale \PYGZsq{}\PYGZus{}\PYGZsq{} for appending n/a vals, here max peaks=10}
                \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{no\PYGZus{}of\PYGZus{}peaks}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                    \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{temp\PYGZus{}periodic}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{nan}\PYG{p}{)}

                \PYG{n}{periodic\PYGZus{}params\PYGZus{}w}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{temp\PYGZus{}periodic}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} append master lists for each subject psd}
    \PYG{n}{epoch\PYGZus{}sub\PYGZus{}w}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{epoch\PYGZus{}w}\PYG{p}{)}
    \PYG{n}{channel\PYGZus{}sub\PYGZus{}w}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{channel\PYGZus{}w}\PYG{p}{)}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}w}\PYG{p}{)}
    \PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}w}\PYG{p}{)}
    \PYG{n}{subject\PYGZus{}sub\PYGZus{}w}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{subject\PYGZus{}w}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Dataframes}

\PYG{c+c1}{\PYGZsh{} make df of periodic\PYGZus{}params and add peak labels}
\PYG{c+c1}{\PYGZsh{} Specify peak labels}
\PYG{n}{peak\PYGZus{}labels} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak6}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak7}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak9}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak10}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{periodic\PYGZus{}params\PYGZus{}w} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Add peak labels}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{peak\PYGZus{}labels}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{peak\PYGZus{}no} \PYG{o}{=} \PYG{n}{periodic\PYGZus{}params\PYGZus{}w}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{[}\PYG{n}{j} \PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{:} \PYG{p}{(}\PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{]}
        \PYG{n}{heading} \PYG{o}{=} \PYG{n}{peak\PYGZus{}labels}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
        \PYG{n}{periodic\PYGZus{}params\PYGZus{}w}\PYG{o}{.}\PYG{n}{rename}\PYG{p}{(}\PYG{n}{columns}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{n}{col}\PYG{p}{:} \PYG{n}{heading} \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n}{peak\PYGZus{}no}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                            \PYG{n}{inplace}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Insert labels}
    \PYG{n}{periodic\PYGZus{}params\PYGZus{}w}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Subject}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{subject\PYGZus{}sub\PYGZus{}w}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{periodic\PYGZus{}params\PYGZus{}w}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{epoch\PYGZus{}sub\PYGZus{}w}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{periodic\PYGZus{}params\PYGZus{}w}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{channel\PYGZus{}sub\PYGZus{}w}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{periodic\PYGZus{}params\PYGZus{}w}

 \PYG{c+c1}{\PYGZsh{} make a df of aperiodic\PYGZus{}params and add parameter labels}
 \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}w} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}w}\PYG{o}{.}\PYG{n}{columns} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Exponent}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R\PYGZca{}2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} Insert labels}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}w}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Subject}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{subject\PYGZus{}sub\PYGZus{}w}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}w}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{epoch\PYGZus{}sub\PYGZus{}w}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}w}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{channel\PYGZus{}sub\PYGZus{}w}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}w}

\PYG{c+c1}{\PYGZsh{} Concatenate the DataFrames within aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w and periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w}
\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{concat}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w}\PYG{p}{)}
\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{concat}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} compiling data into a single wake dataframe}
\PYG{n}{report\PYGZus{}w} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{merge}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w}\PYG{p}{,} \PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w}\PYG{p}{,}
               \PYG{n}{on}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Subject}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}Insert sleepstage label}
\PYG{n}{report\PYGZus{}w}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Stage}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}saving to csv file}
\PYG{n}{report\PYGZus{}w}\PYG{o}{.}\PYG{n}{to\PYGZus{}csv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/CSV/nk\PYGZus{}fooof\PYGZus{}wake.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{index}\PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{The same code structure has been followed for N1, N2, N3 and REM sleepstage with their respective variables and labels}


\subsubsection{b. N1 Sleepstage}
\label{\detokenize{code:b-n1-sleepstage}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} N1 STAGE | Block 5}

\PYG{c+c1}{\PYGZsh{} Initialize empty lists to store data}
\PYG{n}{epoch\PYGZus{}sub\PYGZus{}n1} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{channel\PYGZus{}sub\PYGZus{}n1} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n1} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n1} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{subject\PYGZus{}sub\PYGZus{}n1} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Outer loop}
\PYG{k}{for} \PYG{n}{psd\PYGZus{}n1}\PYG{p}{,} \PYG{n}{file} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{psd\PYGZus{}sub\PYGZus{}n1}\PYG{p}{,} \PYG{n}{psg\PYGZus{}files}\PYG{p}{)}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} initializing empty lists for storing parameters}
    \PYG{n}{epoch\PYGZus{}n1} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{channel\PYGZus{}n1} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n1} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{periodic\PYGZus{}params\PYGZus{}n1} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{subject\PYGZus{}n1} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} Inner loops}
    \PYG{c+c1}{\PYGZsh{} looping over epochs and channel for each subject psd}
    \PYG{k}{for} \PYG{n}{epoch} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{n}{psd\PYGZus{}n1}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{channel} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{psd\PYGZus{}n1}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}

            \PYG{n}{temp\PYGZus{}periodic} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} stores periodic params temporarily}

            \PYG{c+c1}{\PYGZsh{} fitting spectra}
            \PYG{n}{fm}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{freqs}\PYG{p}{,} \PYG{n}{psd\PYGZus{}n1}\PYG{p}{[}\PYG{n}{epoch}\PYG{p}{,} \PYG{n}{channel}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}\PYG{p}{)}

            \PYG{c+c1}{\PYGZsh{} get results}
            \PYG{n}{res\PYGZus{}n1} \PYG{o}{=} \PYG{n}{fm}\PYG{o}{.}\PYG{n}{get\PYGZus{}results}\PYG{p}{(}\PYG{p}{)}

            \PYG{c+c1}{\PYGZsh{}Labels}
            \PYG{c+c1}{\PYGZsh{} updating epoch x channel vals, filename}
            \PYG{n}{epoch\PYGZus{}n1}\PYG{o}{.}\PYG{n}{append} \PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{n1\PYGZus{}Epoch\PYGZus{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{epoch}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{n}{channel\PYGZus{}n1}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Channel\PYGZus{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{channel}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{n}{subject\PYGZus{}n1}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{file}\PYG{p}{)}

            \PYG{c+c1}{\PYGZsh{} Aperiodic Component}
            \PYG{c+c1}{\PYGZsh{} append aperiodic vals to a list}
            \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n1}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{res\PYGZus{}n1}\PYG{o}{.}\PYG{n}{aperiodic\PYGZus{}params}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
                              \PYG{n}{res\PYGZus{}n1}\PYG{o}{.}\PYG{n}{aperiodic\PYGZus{}params}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
                              \PYG{n}{res\PYGZus{}n1}\PYG{o}{.}\PYG{n}{r\PYGZus{}squared}\PYG{p}{,}
                              \PYG{n}{res\PYGZus{}n1}\PYG{o}{.}\PYG{n}{error}\PYG{p}{]}\PYG{p}{)}

            \PYG{c+c1}{\PYGZsh{} Periodic Component}
            \PYG{c+c1}{\PYGZsh{} editing out data for which peaks can\PYGZsq{}t be picked}
            \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{res\PYGZus{}n1}\PYG{o}{.}\PYG{n}{gaussian\PYGZus{}params}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}

                \PYG{c+c1}{\PYGZsh{} n/a vals for periodic params in this case}
                \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                    \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{temp\PYGZus{}periodic}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{nan}\PYG{p}{)}

                \PYG{n}{periodic\PYGZus{}params\PYGZus{}n1}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{temp\PYGZus{}periodic}\PYG{p}{)}

            \PYG{k}{else}\PYG{p}{:}

                \PYG{c+c1}{\PYGZsh{} accessing the nested lists within peak\PYGZus{}params list gives the no of peaks detected}
                \PYG{n}{no\PYGZus{}of\PYGZus{}peaks} \PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{n}{res\PYGZus{}n1}\PYG{o}{.}\PYG{n}{peak\PYGZus{}params}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

                \PYG{c+c1}{\PYGZsh{} appending peak vals and n/a vals to fill for empty peak vals}
                \PYG{k}{for} \PYG{n}{peak} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{no\PYGZus{}of\PYGZus{}peaks}\PYG{p}{)}\PYG{p}{:}
                    \PYG{n}{peak\PYGZus{}pack} \PYG{o}{=} \PYG{n}{res\PYGZus{}n1}\PYG{o}{.}\PYG{n}{peak\PYGZus{}params}\PYG{p}{[}\PYG{n}{peak}\PYG{p}{]}
                    \PYG{k}{for} \PYG{n}{items} \PYG{o+ow}{in} \PYG{n}{peak\PYGZus{}pack}\PYG{p}{:}
                        \PYG{n}{temp\PYGZus{}periodic}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{items}\PYG{p}{)}

                \PYG{c+c1}{\PYGZsh{} using throw away variale \PYGZsq{}\PYGZus{}\PYGZsq{} for appending n/a vals, here max peaks=10}
                \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{no\PYGZus{}of\PYGZus{}peaks}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                    \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{temp\PYGZus{}periodic}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{nan}\PYG{p}{)}

                \PYG{n}{periodic\PYGZus{}params\PYGZus{}n1}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{temp\PYGZus{}periodic}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} append master lists for each subject psd}
    \PYG{n}{epoch\PYGZus{}sub\PYGZus{}n1}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{epoch\PYGZus{}n1}\PYG{p}{)}
    \PYG{n}{channel\PYGZus{}sub\PYGZus{}n1}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{channel\PYGZus{}n1}\PYG{p}{)}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n1}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n1}\PYG{p}{)}
    \PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n1}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}n1}\PYG{p}{)}
    \PYG{n}{subject\PYGZus{}sub\PYGZus{}n1}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{subject\PYGZus{}n1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Dataframes}

\PYG{c+c1}{\PYGZsh{} make df of periodic\PYGZus{}params and add peak labels}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{periodic\PYGZus{}params\PYGZus{}n1} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Add peak labels}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{peak\PYGZus{}labels}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{peak\PYGZus{}no} \PYG{o}{=} \PYG{n}{periodic\PYGZus{}params\PYGZus{}n1}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{[}\PYG{n}{j} \PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{:} \PYG{p}{(}\PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{]}
        \PYG{n}{heading} \PYG{o}{=} \PYG{n}{peak\PYGZus{}labels}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
        \PYG{n}{periodic\PYGZus{}params\PYGZus{}n1}\PYG{o}{.}\PYG{n}{rename}\PYG{p}{(}\PYG{n}{columns}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{n}{col}\PYG{p}{:} \PYG{n}{heading} \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n}{peak\PYGZus{}no}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                            \PYG{n}{inplace}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}Insert labels}
    \PYG{n}{periodic\PYGZus{}params\PYGZus{}n1}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Subject}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{subject\PYGZus{}sub\PYGZus{}n1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{periodic\PYGZus{}params\PYGZus{}n1}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{epoch\PYGZus{}sub\PYGZus{}n1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{periodic\PYGZus{}params\PYGZus{}n1}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{channel\PYGZus{}sub\PYGZus{}n1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{periodic\PYGZus{}params\PYGZus{}n1}

\PYG{c+c1}{\PYGZsh{} make a df of aperiodic\PYGZus{}params and add parameter labels}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n1} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n1}\PYG{o}{.}\PYG{n}{columns} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Exponent}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R\PYGZca{}2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{}Insert labels}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n1}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Subject}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{subject\PYGZus{}sub\PYGZus{}n1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n1}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{epoch\PYGZus{}sub\PYGZus{}n1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n1}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{channel\PYGZus{}sub\PYGZus{}n1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n1}

\PYG{c+c1}{\PYGZsh{} Concatenate the DataFrames within aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w and periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w}
\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n1} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{concat}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n1}\PYG{p}{)}
\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n1} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{concat}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} compiling data into a single wake dataframe}
\PYG{n}{report\PYGZus{}n1} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{merge}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n1}\PYG{p}{,} \PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n1}\PYG{p}{,}
                \PYG{n}{on}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Subject}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}Insert sleepstage label}
\PYG{n}{report\PYGZus{}n1}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Stage}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}saving to csv file}
\PYG{n}{report\PYGZus{}n1}\PYG{o}{.}\PYG{n}{to\PYGZus{}csv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/CSV/nk\PYGZus{}fooof\PYGZus{}n1.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{index}\PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{c. N2 Sleepstage}
\label{\detokenize{code:c-n2-sleepstage}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} N2 STAGE | Block 6}

\PYG{c+c1}{\PYGZsh{} Initialize empty lists to store data}
\PYG{n}{epoch\PYGZus{}sub\PYGZus{}n2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{channel\PYGZus{}sub\PYGZus{}n2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{subject\PYGZus{}sub\PYGZus{}n2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Outer loop}
\PYG{k}{for} \PYG{n}{psd\PYGZus{}n2}\PYG{p}{,} \PYG{n}{file} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{psd\PYGZus{}sub\PYGZus{}n2}\PYG{p}{,} \PYG{n}{psg\PYGZus{}files}\PYG{p}{)}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} initializing empty lists for storing parameters}
    \PYG{n}{epoch\PYGZus{}n2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{channel\PYGZus{}n2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{periodic\PYGZus{}params\PYGZus{}n2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{subject\PYGZus{}n2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} Inner loops}
    \PYG{c+c1}{\PYGZsh{} looping over epochs and channel for each subject psd}
    \PYG{k}{for} \PYG{n}{epoch} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{n}{psd\PYGZus{}n2}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{channel} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{psd\PYGZus{}n2}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}

            \PYG{n}{temp\PYGZus{}periodic} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} stores periodic params temporarily}

            \PYG{c+c1}{\PYGZsh{} fitting spectra}
            \PYG{n}{fm}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{freqs}\PYG{p}{,} \PYG{n}{psd\PYGZus{}n2}\PYG{p}{[}\PYG{n}{epoch}\PYG{p}{,} \PYG{n}{channel}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}\PYG{p}{)}

            \PYG{c+c1}{\PYGZsh{} get results}
            \PYG{n}{res\PYGZus{}n2} \PYG{o}{=} \PYG{n}{fm}\PYG{o}{.}\PYG{n}{get\PYGZus{}results}\PYG{p}{(}\PYG{p}{)}

            \PYG{c+c1}{\PYGZsh{} Labels}
            \PYG{c+c1}{\PYGZsh{} updating epoch x channel vals, filename}
            \PYG{n}{epoch\PYGZus{}n2}\PYG{o}{.}\PYG{n}{append} \PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{n2\PYGZus{}Epoch\PYGZus{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{epoch}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{n}{channel\PYGZus{}n2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Channel\PYGZus{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{channel}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{n}{subject\PYGZus{}n2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{file}\PYG{p}{)}

            \PYG{c+c1}{\PYGZsh{} Aperiodic Component}
            \PYG{c+c1}{\PYGZsh{} append aperiodic vals to a list}
            \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{res\PYGZus{}n2}\PYG{o}{.}\PYG{n}{aperiodic\PYGZus{}params}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
                                     \PYG{n}{res\PYGZus{}n2}\PYG{o}{.}\PYG{n}{aperiodic\PYGZus{}params}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
                                     \PYG{n}{res\PYGZus{}n2}\PYG{o}{.}\PYG{n}{r\PYGZus{}squared}\PYG{p}{,}
                                     \PYG{n}{res\PYGZus{}n2}\PYG{o}{.}\PYG{n}{error}\PYG{p}{]}\PYG{p}{)}

            \PYG{c+c1}{\PYGZsh{} Periodic Component}
            \PYG{c+c1}{\PYGZsh{} editing out data for which peaks can\PYGZsq{}t be picked}
            \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{res\PYGZus{}n2}\PYG{o}{.}\PYG{n}{gaussian\PYGZus{}params}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}

                \PYG{c+c1}{\PYGZsh{} n/a vals for periodic params in this case}
                \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                    \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{temp\PYGZus{}periodic}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{nan}\PYG{p}{)}

                \PYG{n}{periodic\PYGZus{}params\PYGZus{}n2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{temp\PYGZus{}periodic}\PYG{p}{)}

            \PYG{k}{else}\PYG{p}{:}

                \PYG{c+c1}{\PYGZsh{} accessing the nested lists within peak\PYGZus{}params list gives the no of peaks detected}
                \PYG{n}{no\PYGZus{}of\PYGZus{}peaks} \PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{n}{res\PYGZus{}n2}\PYG{o}{.}\PYG{n}{peak\PYGZus{}params}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

                \PYG{c+c1}{\PYGZsh{} appending peak vals and n/a vals to fill for empty peak vals}
                \PYG{k}{for} \PYG{n}{peak} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{no\PYGZus{}of\PYGZus{}peaks}\PYG{p}{)}\PYG{p}{:}
                    \PYG{n}{peak\PYGZus{}pack} \PYG{o}{=} \PYG{n}{res\PYGZus{}n2}\PYG{o}{.}\PYG{n}{peak\PYGZus{}params}\PYG{p}{[}\PYG{n}{peak}\PYG{p}{]}
                    \PYG{k}{for} \PYG{n}{items} \PYG{o+ow}{in} \PYG{n}{peak\PYGZus{}pack}\PYG{p}{:}
                        \PYG{n}{temp\PYGZus{}periodic}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{items}\PYG{p}{)}

                \PYG{c+c1}{\PYGZsh{} using throw away variale \PYGZsq{}\PYGZus{}\PYGZsq{} for appending n/a vals, here max peaks=10}
                \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{no\PYGZus{}of\PYGZus{}peaks}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                    \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{temp\PYGZus{}periodic}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{nan}\PYG{p}{)}

                \PYG{n}{periodic\PYGZus{}params\PYGZus{}n2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{temp\PYGZus{}periodic}\PYG{p}{)}

   \PYG{c+c1}{\PYGZsh{} append master lists for each subject psd}
    \PYG{n}{epoch\PYGZus{}sub\PYGZus{}n2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{epoch\PYGZus{}n2}\PYG{p}{)}
    \PYG{n}{channel\PYGZus{}sub\PYGZus{}n2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{channel\PYGZus{}n2}\PYG{p}{)}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n2}\PYG{p}{)}
    \PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}n2}\PYG{p}{)}
    \PYG{n}{subject\PYGZus{}sub\PYGZus{}n2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{subject\PYGZus{}n2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Dataframes}

\PYG{c+c1}{\PYGZsh{} make df of periodic\PYGZus{}params and add peak labels}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{periodic\PYGZus{}params\PYGZus{}n2} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Add peak labels}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{peak\PYGZus{}labels}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{peak\PYGZus{}no} \PYG{o}{=} \PYG{n}{periodic\PYGZus{}params\PYGZus{}n2}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{[}\PYG{n}{j} \PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{:} \PYG{p}{(}\PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{]}
        \PYG{n}{heading} \PYG{o}{=} \PYG{n}{peak\PYGZus{}labels}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
        \PYG{n}{periodic\PYGZus{}params\PYGZus{}n2}\PYG{o}{.}\PYG{n}{rename}\PYG{p}{(}\PYG{n}{columns}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{n}{col}\PYG{p}{:} \PYG{n}{heading} \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n}{peak\PYGZus{}no}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                            \PYG{n}{inplace}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Insert labels}
    \PYG{n}{periodic\PYGZus{}params\PYGZus{}n2}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Subject}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{subject\PYGZus{}sub\PYGZus{}n2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{periodic\PYGZus{}params\PYGZus{}n2}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{epoch\PYGZus{}sub\PYGZus{}n2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{periodic\PYGZus{}params\PYGZus{}n2}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{channel\PYGZus{}sub\PYGZus{}n2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{periodic\PYGZus{}params\PYGZus{}n2}


\PYG{c+c1}{\PYGZsh{} make a df of aperiodic\PYGZus{}params and add parameter labels}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n2} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n2}\PYG{o}{.}\PYG{n}{columns} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Exponent}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R\PYGZca{}2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} Insert labels}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n2}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Subject}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{subject\PYGZus{}sub\PYGZus{}n2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n2}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{epoch\PYGZus{}sub\PYGZus{}n2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n2}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{channel\PYGZus{}sub\PYGZus{}n2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n2}

\PYG{c+c1}{\PYGZsh{} Concatenate the DataFrames within aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w and periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w}
\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n2} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{concat}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n2}\PYG{p}{)}
\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n2} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{concat}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} compiling data into a single wake dataframe}
\PYG{n}{report\PYGZus{}n2} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{merge}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n2}\PYG{p}{,} \PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n2}\PYG{p}{,}
                \PYG{n}{on}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Subject}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Insert slepstage label}
\PYG{n}{report\PYGZus{}n2}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Stage}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}saving to csv file}
\PYG{n}{report\PYGZus{}n2}\PYG{o}{.}\PYG{n}{to\PYGZus{}csv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/CSV/nk\PYGZus{}fooof\PYGZus{}n2.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{index}\PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{d. N3 Sleepstage}
\label{\detokenize{code:d-n3-sleepstage}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} N3 STAGE | Block 7}

\PYG{c+c1}{\PYGZsh{} Initialize empty lists to store data}
\PYG{n}{epoch\PYGZus{}sub\PYGZus{}n3} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{channel\PYGZus{}sub\PYGZus{}n3} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n3} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n3} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{subject\PYGZus{}sub\PYGZus{}n3} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Outer loop}
\PYG{k}{for} \PYG{n}{psd\PYGZus{}n3}\PYG{p}{,} \PYG{n}{file} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{psd\PYGZus{}sub\PYGZus{}n3}\PYG{p}{,} \PYG{n}{psg\PYGZus{}files}\PYG{p}{)}\PYG{p}{:}

         \PYG{c+c1}{\PYGZsh{} initializing empty lists for storing parameters}
         \PYG{n}{epoch\PYGZus{}n3} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
         \PYG{n}{channel\PYGZus{}n3} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
         \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n3} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
         \PYG{n}{periodic\PYGZus{}params\PYGZus{}n3} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
         \PYG{n}{subject\PYGZus{}n3} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

         \PYG{c+c1}{\PYGZsh{} Inner loops}
         \PYG{c+c1}{\PYGZsh{} looping over epochs and channel for each subject psd}
         \PYG{k}{for} \PYG{n}{epoch} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{n}{psd\PYGZus{}n3}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
                  \PYG{k}{for} \PYG{n}{channel} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{psd\PYGZus{}n3}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}

                                \PYG{n}{temp\PYGZus{}periodic} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} stores periodic params temporarily}

                                \PYG{c+c1}{\PYGZsh{} fitting spectra}
                                \PYG{n}{fm}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{freqs}\PYG{p}{,} \PYG{n}{psd\PYGZus{}n3}\PYG{p}{[}\PYG{n}{epoch}\PYG{p}{,} \PYG{n}{channel}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}\PYG{p}{)}

                                \PYG{c+c1}{\PYGZsh{} get results}
                                \PYG{n}{res\PYGZus{}n3} \PYG{o}{=} \PYG{n}{fm}\PYG{o}{.}\PYG{n}{get\PYGZus{}results}\PYG{p}{(}\PYG{p}{)}

                                \PYG{c+c1}{\PYGZsh{} Labels}
                                \PYG{c+c1}{\PYGZsh{} updating epoch x channel vals, filename}
                                \PYG{n}{epoch\PYGZus{}n3}\PYG{o}{.}\PYG{n}{append} \PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{n3\PYGZus{}Epoch\PYGZus{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{epoch}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
                                \PYG{n}{channel\PYGZus{}n3}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Channel\PYGZus{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{channel}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
                                \PYG{n}{subject\PYGZus{}n3}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{file}\PYG{p}{)}

                                \PYG{c+c1}{\PYGZsh{} Aperiodic Component}
                                \PYG{c+c1}{\PYGZsh{} append aperiodic vals to a list}
                                \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n3}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{res\PYGZus{}n3}\PYG{o}{.}\PYG{n}{aperiodic\PYGZus{}params}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
                                                                \PYG{n}{res\PYGZus{}n3}\PYG{o}{.}\PYG{n}{aperiodic\PYGZus{}params}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
                                                                \PYG{n}{res\PYGZus{}n3}\PYG{o}{.}\PYG{n}{r\PYGZus{}squared}\PYG{p}{,}
                                                                \PYG{n}{res\PYGZus{}n3}\PYG{o}{.}\PYG{n}{error}\PYG{p}{]}\PYG{p}{)}

                                \PYG{c+c1}{\PYGZsh{} Periodic Component}
                                \PYG{c+c1}{\PYGZsh{} editing out data for which peaks can\PYGZsq{}t be picked}
                                \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{res\PYGZus{}n3}\PYG{o}{.}\PYG{n}{gaussian\PYGZus{}params}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}

                                         \PYG{c+c1}{\PYGZsh{} n/a vals for periodic params in this case}
                                         \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                                                  \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
                                                                \PYG{n}{temp\PYGZus{}periodic}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{nan}\PYG{p}{)}

                                         \PYG{n}{periodic\PYGZus{}params\PYGZus{}n3}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{temp\PYGZus{}periodic}\PYG{p}{)}

                                \PYG{k}{else}\PYG{p}{:}

                                         \PYG{c+c1}{\PYGZsh{} accessing the nested lists within peak\PYGZus{}params list gives the no of peaks detected}
                                         \PYG{n}{no\PYGZus{}of\PYGZus{}peaks} \PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{n}{res\PYGZus{}n3}\PYG{o}{.}\PYG{n}{peak\PYGZus{}params}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

                                         \PYG{c+c1}{\PYGZsh{} appending peak vals and n/a vals to fill for empty peak vals}
                                         \PYG{k}{for} \PYG{n}{peak} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{no\PYGZus{}of\PYGZus{}peaks}\PYG{p}{)}\PYG{p}{:}
                                                  \PYG{n}{peak\PYGZus{}pack} \PYG{o}{=} \PYG{n}{res\PYGZus{}n3}\PYG{o}{.}\PYG{n}{peak\PYGZus{}params}\PYG{p}{[}\PYG{n}{peak}\PYG{p}{]}
                                                  \PYG{k}{for} \PYG{n}{items} \PYG{o+ow}{in} \PYG{n}{peak\PYGZus{}pack}\PYG{p}{:}
                                                                \PYG{n}{temp\PYGZus{}periodic}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{items}\PYG{p}{)}

                                         \PYG{c+c1}{\PYGZsh{} using throw away variale \PYGZsq{}\PYGZus{}\PYGZsq{} for appending n/a vals, here max peaks=10}
                                         \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{no\PYGZus{}of\PYGZus{}peaks}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                                                  \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
                                                                \PYG{n}{temp\PYGZus{}periodic}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{nan}\PYG{p}{)}

                                         \PYG{n}{periodic\PYGZus{}params\PYGZus{}n3}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{temp\PYGZus{}periodic}\PYG{p}{)}

         \PYG{c+c1}{\PYGZsh{} append master lists for each subject psd}
         \PYG{n}{epoch\PYGZus{}sub\PYGZus{}n3}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{epoch\PYGZus{}n3}\PYG{p}{)}
         \PYG{n}{channel\PYGZus{}sub\PYGZus{}n3}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{channel\PYGZus{}n3}\PYG{p}{)}
         \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n3}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n3}\PYG{p}{)}
         \PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n3}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}n3}\PYG{p}{)}
         \PYG{n}{subject\PYGZus{}sub\PYGZus{}n3}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{subject\PYGZus{}n3}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Dataframes}

\PYG{c+c1}{\PYGZsh{} make df of periodic\PYGZus{}params and add peak labels}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}

         \PYG{n}{periodic\PYGZus{}params\PYGZus{}n3} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n3}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Add peak labels}
         \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{peak\PYGZus{}labels}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                  \PYG{n}{peak\PYGZus{}no} \PYG{o}{=} \PYG{n}{periodic\PYGZus{}params\PYGZus{}n3}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{[}\PYG{n}{j} \PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{:} \PYG{p}{(}\PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{]}
                  \PYG{n}{heading} \PYG{o}{=} \PYG{n}{peak\PYGZus{}labels}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
                  \PYG{n}{periodic\PYGZus{}params\PYGZus{}n3}\PYG{o}{.}\PYG{n}{rename}\PYG{p}{(}\PYG{n}{columns}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{n}{col}\PYG{p}{:} \PYG{n}{heading} \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n}{peak\PYGZus{}no}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                                            \PYG{n}{inplace}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

         \PYG{c+c1}{\PYGZsh{} Insert labels}
         \PYG{n}{periodic\PYGZus{}params\PYGZus{}n3}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Subject}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{subject\PYGZus{}sub\PYGZus{}n3}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
         \PYG{n}{periodic\PYGZus{}params\PYGZus{}n3}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{epoch\PYGZus{}sub\PYGZus{}n3}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
         \PYG{n}{periodic\PYGZus{}params\PYGZus{}n3}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{channel\PYGZus{}sub\PYGZus{}n3}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

         \PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n3}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{periodic\PYGZus{}params\PYGZus{}n3}

\PYG{c+c1}{\PYGZsh{} make a df of aperiodic\PYGZus{}params and add parameter labels}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}

         \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n3} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n3}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
         \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n3}\PYG{o}{.}\PYG{n}{columns} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Exponent}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R\PYGZca{}2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

         \PYG{c+c1}{\PYGZsh{} Insert labels}
         \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n3}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Subject}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{subject\PYGZus{}sub\PYGZus{}n3}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
         \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n3}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{epoch\PYGZus{}sub\PYGZus{}n3}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
         \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n3}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{channel\PYGZus{}sub\PYGZus{}n3}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

         \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n3}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}n3}

\PYG{c+c1}{\PYGZsh{} Concatenate the DataFrames within aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w and periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w}
\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n3} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{concat}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n3}\PYG{p}{)}
\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n3} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{concat}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n3}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} compiling data into a single wake dataframe}
\PYG{n}{report\PYGZus{}n3} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{merge}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n3}\PYG{p}{,} \PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}n3}\PYG{p}{,}
            \PYG{n}{on}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Subject}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Insert sleepstage labels}
\PYG{n}{report\PYGZus{}n3}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Stage}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}saving to csv file}
\PYG{n}{report\PYGZus{}n3}\PYG{o}{.}\PYG{n}{to\PYGZus{}csv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/CSV/nk\PYGZus{}fooof\PYGZus{}n3.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{index}\PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{e. REM Sleepstage}
\label{\detokenize{code:e-rem-sleepstage}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} REM STAGE | Block 8}

\PYG{c+c1}{\PYGZsh{} Initialize empty lists to store data}
\PYG{n}{epoch\PYGZus{}sub\PYGZus{}rem} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{channel\PYGZus{}sub\PYGZus{}rem} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}rem} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}rem} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{subject\PYGZus{}sub\PYGZus{}rem} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Outer loop}
\PYG{k}{for} \PYG{n}{psd\PYGZus{}rem}\PYG{p}{,} \PYG{n}{file} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{psd\PYGZus{}sub\PYGZus{}rem}\PYG{p}{,} \PYG{n}{psg\PYGZus{}files}\PYG{p}{)}\PYG{p}{:}

         \PYG{c+c1}{\PYGZsh{} initializing empty lists for storing parameters}
         \PYG{n}{epoch\PYGZus{}rem} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
         \PYG{n}{channel\PYGZus{}rem} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
         \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}rem} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
         \PYG{n}{periodic\PYGZus{}params\PYGZus{}rem} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
         \PYG{n}{subject\PYGZus{}rem} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

         \PYG{c+c1}{\PYGZsh{} Inner loops}
         \PYG{c+c1}{\PYGZsh{} looping over epochs and channel,outcome\PYGZhy{} epoch x channel no of data entries}
         \PYG{c+c1}{\PYGZsh{} for each subject psd}
         \PYG{k}{for} \PYG{n}{epoch} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{n}{psd\PYGZus{}rem}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
                  \PYG{k}{for} \PYG{n}{channel} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{psd\PYGZus{}rem}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}

                                \PYG{n}{temp\PYGZus{}periodic} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} stores periodic params temporarily}

                                \PYG{c+c1}{\PYGZsh{} fitting spectra}
                                \PYG{n}{fm}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{freqs}\PYG{p}{,} \PYG{n}{psd\PYGZus{}rem}\PYG{p}{[}\PYG{n}{epoch}\PYG{p}{,} \PYG{n}{channel}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}\PYG{p}{)}

                                \PYG{c+c1}{\PYGZsh{} get results}
                                \PYG{n}{res\PYGZus{}rem} \PYG{o}{=} \PYG{n}{fm}\PYG{o}{.}\PYG{n}{get\PYGZus{}results}\PYG{p}{(}\PYG{p}{)}

                                \PYG{c+c1}{\PYGZsh{} Labels}
                                \PYG{c+c1}{\PYGZsh{} updating epoch x channel vals, filename}
                                \PYG{n}{epoch\PYGZus{}rem}\PYG{o}{.}\PYG{n}{append} \PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{rem\PYGZus{}Epoch\PYGZus{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{epoch}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
                                \PYG{n}{channel\PYGZus{}rem}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Channel\PYGZus{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{channel}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
                                \PYG{n}{subject\PYGZus{}rem}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{file}\PYG{p}{)}

                                \PYG{c+c1}{\PYGZsh{} Aperiodic Component}
                                \PYG{c+c1}{\PYGZsh{} append aperiodic vals to a list}
                                \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}rem}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{res\PYGZus{}rem}\PYG{o}{.}\PYG{n}{aperiodic\PYGZus{}params}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
                                                                \PYG{n}{res\PYGZus{}rem}\PYG{o}{.}\PYG{n}{aperiodic\PYGZus{}params}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
                                                                \PYG{n}{res\PYGZus{}rem}\PYG{o}{.}\PYG{n}{r\PYGZus{}squared}\PYG{p}{,}
                                                                \PYG{n}{res\PYGZus{}rem}\PYG{o}{.}\PYG{n}{error}\PYG{p}{]}\PYG{p}{)}

                                \PYG{c+c1}{\PYGZsh{} Periodic Component}
                                \PYG{c+c1}{\PYGZsh{} editing out data for which peaks can\PYGZsq{}t be picked}
                                \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{res\PYGZus{}rem}\PYG{o}{.}\PYG{n}{gaussian\PYGZus{}params}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}

                                         \PYG{c+c1}{\PYGZsh{} n/a vals for periodic params in this case}
                                         \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                                                  \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
                                                                \PYG{n}{temp\PYGZus{}periodic}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{nan}\PYG{p}{)}

                                         \PYG{n}{periodic\PYGZus{}params\PYGZus{}rem}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{temp\PYGZus{}periodic}\PYG{p}{)}

                                \PYG{k}{else}\PYG{p}{:}

                                         \PYG{c+c1}{\PYGZsh{} accessing the nested lists within peak\PYGZus{}params list gives the no of peaks detected}
                                         \PYG{n}{no\PYGZus{}of\PYGZus{}peaks} \PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{n}{res\PYGZus{}rem}\PYG{o}{.}\PYG{n}{peak\PYGZus{}params}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

                                         \PYG{c+c1}{\PYGZsh{} appending peak vals and n/a vals to fill for empty peak vals}
                                         \PYG{k}{for} \PYG{n}{peak} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{no\PYGZus{}of\PYGZus{}peaks}\PYG{p}{)}\PYG{p}{:}
                                                  \PYG{n}{peak\PYGZus{}pack} \PYG{o}{=} \PYG{n}{res\PYGZus{}rem}\PYG{o}{.}\PYG{n}{peak\PYGZus{}params}\PYG{p}{[}\PYG{n}{peak}\PYG{p}{]}
                                                  \PYG{k}{for} \PYG{n}{items} \PYG{o+ow}{in} \PYG{n}{peak\PYGZus{}pack}\PYG{p}{:}
                                                                \PYG{n}{temp\PYGZus{}periodic}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{items}\PYG{p}{)}

                                         \PYG{c+c1}{\PYGZsh{} using throw away variale \PYGZsq{}\PYGZus{}\PYGZsq{} for appending n/a vals, here max peaks=10}
                                         \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{no\PYGZus{}of\PYGZus{}peaks}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                                                  \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
                                                                \PYG{n}{temp\PYGZus{}periodic}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{nan}\PYG{p}{)}

                                         \PYG{n}{periodic\PYGZus{}params\PYGZus{}rem}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{temp\PYGZus{}periodic}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} append master lists for each subject psd}
         \PYG{n}{epoch\PYGZus{}sub\PYGZus{}rem}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{epoch\PYGZus{}rem}\PYG{p}{)}
         \PYG{n}{channel\PYGZus{}sub\PYGZus{}rem}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{channel\PYGZus{}rem}\PYG{p}{)}
         \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}rem}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}rem}\PYG{p}{)}
         \PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}rem}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}rem}\PYG{p}{)}
         \PYG{n}{subject\PYGZus{}sub\PYGZus{}rem}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{subject\PYGZus{}rem}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Dataframes}

\PYG{c+c1}{\PYGZsh{} make df of periodic\PYGZus{}params and add peak labels}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}rem}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
         \PYG{n}{periodic\PYGZus{}params\PYGZus{}rem} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}rem}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Add peak labels}
         \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{peak\PYGZus{}labels}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                  \PYG{n}{peak\PYGZus{}no} \PYG{o}{=} \PYG{n}{periodic\PYGZus{}params\PYGZus{}rem}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{[}\PYG{n}{j} \PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{:} \PYG{p}{(}\PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{]}
                  \PYG{n}{heading} \PYG{o}{=} \PYG{n}{peak\PYGZus{}labels}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
                  \PYG{n}{periodic\PYGZus{}params\PYGZus{}rem}\PYG{o}{.}\PYG{n}{rename}\PYG{p}{(}\PYG{n}{columns}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{n}{col}\PYG{p}{:} \PYG{n}{heading} \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n}{peak\PYGZus{}no}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                                             \PYG{n}{inplace}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

         \PYG{c+c1}{\PYGZsh{} Insert labels}
         \PYG{n}{periodic\PYGZus{}params\PYGZus{}rem}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Subject}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{subject\PYGZus{}sub\PYGZus{}rem}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
         \PYG{n}{periodic\PYGZus{}params\PYGZus{}rem}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{epoch\PYGZus{}sub\PYGZus{}rem}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
         \PYG{n}{periodic\PYGZus{}params\PYGZus{}rem}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{channel\PYGZus{}sub\PYGZus{}rem}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

         \PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}rem}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{periodic\PYGZus{}params\PYGZus{}rem}

\PYG{c+c1}{\PYGZsh{} make a df of aperiodic\PYGZus{}params and add parameter labels}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}rem}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
         \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}rem} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}rem}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
         \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}rem}\PYG{o}{.}\PYG{n}{columns} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Exponent}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R\PYGZca{}2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

         \PYG{c+c1}{\PYGZsh{} Insert labels}
         \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}rem}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Subject}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{subject\PYGZus{}sub\PYGZus{}rem}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
         \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}rem}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{epoch\PYGZus{}sub\PYGZus{}rem}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
         \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}rem}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{channel\PYGZus{}sub\PYGZus{}rem}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

         \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}rem}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{aperiodic\PYGZus{}params\PYGZus{}rem}

\PYG{c+c1}{\PYGZsh{} Concatenate the DataFrames within aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w and periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}w}
\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}rem} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{concat}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}rem}\PYG{p}{)}
\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}rem} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{concat}\PYG{p}{(}\PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}rem}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} compiling data into a single wake dataframe}
\PYG{n}{report\PYGZus{}rem} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{merge}\PYG{p}{(}\PYG{n}{aperiodic\PYGZus{}params\PYGZus{}sub\PYGZus{}rem}\PYG{p}{,} \PYG{n}{periodic\PYGZus{}params\PYGZus{}sub\PYGZus{}rem}\PYG{p}{,}
             \PYG{n}{on}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Epoch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Subject}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Insert sleepstage labels}
\PYG{n}{report\PYGZus{}rem}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Stage}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{REM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}saving to csv file}
\PYG{n}{report\PYGZus{}rem}\PYG{o}{.}\PYG{n}{to\PYGZus{}csv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/CSV/nk\PYGZus{}fooof\PYGZus{}rem.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{index}\PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{6. Compiling Data}
\label{\detokenize{code:compiling-data}}
\sphinxAtStartPar
This block of code compiles all sleepstage dataframes into a single dataframe \sphinxcode{\sphinxupquote{report\_sleepstages}}.
Remove data with \sphinxcode{\sphinxupquote{R\textasciicircum{}2}} value below 0.9. The block makes a dataframe solely for the Aperiodic Component of EEG Data which will be used in analysis.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} Compile all sleepstages into one | Block 9}

\PYG{c+c1}{\PYGZsh{}compile dataframe and save it to a csv file}
\PYG{n}{report\PYGZus{}sleepstages} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{concat}\PYG{p}{(}\PYG{p}{[}\PYG{n}{report\PYGZus{}w}\PYG{p}{,}\PYG{n}{report\PYGZus{}n1}\PYG{p}{,}\PYG{n}{report\PYGZus{}n2}\PYG{p}{,}\PYG{n}{report\PYGZus{}n3}\PYG{p}{,}\PYG{n}{report\PYGZus{}rem}\PYG{p}{]}\PYG{p}{,}
                                                                \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{report\PYGZus{}sleepstages}\PYG{o}{.}\PYG{n}{reset\PYGZus{}index}\PYG{p}{(}\PYG{n}{drop}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{inplace}\PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}saving to csv file}
\PYG{n}{report\PYGZus{}sleepstages}\PYG{o}{.}\PYG{n}{to\PYGZus{}csv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/CSV/nk\PYGZus{}fooof\PYGZus{}sleepdata.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{index}\PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}remove periodic params and entries with r\PYGZus{}squred vals \PYGZlt{}0.9}
\PYG{n}{report\PYGZus{}sleepstages\PYGZus{}II} \PYG{o}{=} \PYG{n}{report\PYGZus{}sleepstages}\PYG{o}{.}\PYG{n}{drop}\PYG{p}{(}\PYG{n}{report\PYGZus{}sleepstages}\PYG{o}{.}\PYG{n}{columns}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{:}\PYG{l+m+mi}{38}\PYG{p}{]}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{report\PYGZus{}sleepstages\PYGZus{}II} \PYG{o}{=} \PYG{n}{report\PYGZus{}sleepstages\PYGZus{}II}\PYG{p}{[}\PYG{n}{report\PYGZus{}sleepstages\PYGZus{}II}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R\PYGZca{}2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mf}{0.9}\PYG{p}{]}

\PYG{n}{report\PYGZus{}sleepstages\PYGZus{}II}\PYG{o}{.}\PYG{n}{reset\PYGZus{}index}\PYG{p}{(}\PYG{n}{drop}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{inplace}\PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{7. Averaging across Epochs}
\label{\detokenize{code:averaging-across-epochs}}
\sphinxAtStartPar
This block computes the average values and trimmed mean across epochs for each sleep stage and channel.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Group by stage and channel, then take the mean of the aperiodic and periodic components for all epochs.

\item {} 
\sphinxAtStartPar
Compute the trimmed mean for each column (\sphinxcode{\sphinxupquote{Exponent}}, \sphinxcode{\sphinxupquote{Offset}}, \sphinxcode{\sphinxupquote{R\textasciicircum{}2}}, \sphinxcode{\sphinxupquote{Error}}) in the \sphinxcode{\sphinxupquote{report\_sleepstages\_II}} DataFrame, and add columns containing the trimmed mean values to the \sphinxcode{\sphinxupquote{Channel\_avg\_vals}} DataFrame.

\item {} 
\sphinxAtStartPar
Reset the index of the \sphinxcode{\sphinxupquote{Channel\_avg\_vals}} DataFrame to convert the grouped columns (‘Channel’ and ‘Stage’) back to regular columns.

\item {} 
\sphinxAtStartPar
Extract the channel number from the \sphinxcode{\sphinxupquote{Channel}} column, convert it to an integer and update the \sphinxcode{\sphinxupquote{Channel}} column in \sphinxcode{\sphinxupquote{Channel\_avg\_vals}}.

\item {} 
\sphinxAtStartPar
Sort the DataFrame by \sphinxcode{\sphinxupquote{Channel}} and \sphinxcode{\sphinxupquote{Stage}} in ascending order.

\item {} 
\sphinxAtStartPar
Again reset the index of \sphinxcode{\sphinxupquote{Channel\_avg\_vals}} and drop the old index to get a clean DataFrame containing the averaged values and trimmed means for each channel and sleep stage.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} AVERAGING ACROSS EPOCHS | Block 10}

\PYG{c+c1}{\PYGZsh{} Trimmed mean}
\PYG{c+c1}{\PYGZsh{} Define the trim percentage (here, 10\PYGZpc{})}
\PYG{n}{trim\PYGZus{}percentage} \PYG{o}{=} \PYG{l+m+mf}{0.1}

\PYG{c+c1}{\PYGZsh{}  Group by columns and calculate trimmed mean for each group}
\PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals} \PYG{o}{=} \PYG{n}{report\PYGZus{}sleepstages\PYGZus{}II}\PYG{o}{.}\PYG{n}{groupby}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Stage}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{group}\PYG{p}{:} \PYG{n}{group}\PYG{o}{.}\PYG{n}{iloc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{trim\PYGZus{}mean}\PYG{p}{,} \PYG{n}{proportiontocut}\PYG{o}{=}\PYG{n}{trim\PYGZus{}percentage}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}reset the index to convert the grouped columns (\PYGZsq{}Channel\PYGZsq{} and \PYGZsq{}Stage\PYGZsq{}) back to regular columns}
\PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{o}{.}\PYG{n}{reset\PYGZus{}index}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Extracting the channel number from the \PYGZsq{}Channel\PYGZsq{} column}
\PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{str}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{str}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Sorting the DataFrame by \PYGZsq{}Channel\PYGZsq{} and \PYGZsq{}Stage\PYGZsq{}}
\PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{o}{.}\PYG{n}{sort\PYGZus{}values}\PYG{p}{(}\PYG{n}{by}\PYG{o}{=}\PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Stage}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ascending}\PYG{o}{=}\PYG{p}{[}\PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{o}{.}\PYG{n}{reset\PYGZus{}index}\PYG{p}{(}\PYG{n}{drop}\PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{inplace}\PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{8. Plotting Results}
\label{\detokenize{code:plotting-results}}

\subsubsection{a. Topoplot}
\label{\detokenize{code:a-topoplot}}
\sphinxAtStartPar
The following blocks generates topoplots for the exponent and offset values corresponding to 19 selected channels and 5 sleep stages.

\sphinxAtStartPar
The topoplots provide a visual representation of the distribution of these values across different channels and sleep stages.

\sphinxAtStartPar
\sphinxstylestrong{Parameters for Topoplot (Block 11):}

\sphinxAtStartPar
Specify the channels to be included in the topoplot using the channels\_to\_pick\_topo list.

\sphinxAtStartPar
The code creates 2D dataframes (\sphinxcode{\sphinxupquote{Exponent\_vals}} and \sphinxcode{\sphinxupquote{Offset\_vals}}) containing the exponent and offset values for each channel across the five sleep stages.

\sphinxAtStartPar
The index of the dataframes is set to the channel names for visualization using \sphinxcode{\sphinxupquote{yasa}}.

\sphinxAtStartPar
\sphinxstylestrong{Topoplot Generation (Block 12):}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Exponent Topoplots

\end{itemize}

\sphinxAtStartPar
The code iterates through the sleep stages and generates topoplots for the exponent values.

\sphinxAtStartPar
For each stage, we define the color scale using the maximum and minimum exponent values across all channels and stages.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{yasa.topoplot}} function is then called to create the topoplot, and \sphinxcode{\sphinxupquote{plt.show()}} displays it.

\sphinxAtStartPar
Additionally, the topoplot is saved as an image file in the specified location.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Offset Topoplots

\end{itemize}

\sphinxAtStartPar
Similarly, the code generates topoplots for the offset values. The process is similar to that of the exponent topoplots, with appropriate color scaling, plotting, and saving.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} Parameters for Topoplot | Block 11}

\PYG{n}{channels\PYGZus{}to\PYGZus{}pick\PYGZus{}topo} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fp1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fp2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F7}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Pz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Exponet vals}

\PYG{c+c1}{\PYGZsh{} make a 2D dataframe containing exponent vals corresponding to 19 channels for 5 sleepstages}
\PYG{n}{Exponent\PYGZus{}vals} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{o}{.}\PYG{n}{pivot}\PYG{p}{(}\PYG{n}{index}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{columns}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Stage}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{values}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Exponent}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} The index MUST be the channel names for yasa}
\PYG{n}{Exponent\PYGZus{}vals}\PYG{o}{.}\PYG{n}{index} \PYG{o}{=} \PYG{n}{channels\PYGZus{}to\PYGZus{}pick\PYGZus{}topo}

\PYG{c+c1}{\PYGZsh{} Offset vals}

\PYG{c+c1}{\PYGZsh{} make a 2D dataframe containing offset vals corresponding to 19 channels for 5 sleepstages}
\PYG{n}{Offset\PYGZus{}vals} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{o}{.}\PYG{n}{pivot}\PYG{p}{(}\PYG{n}{index}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{columns}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Stage}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{values}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} The index MUST be the channel names for yasa}
\PYG{n}{Offset\PYGZus{}vals}\PYG{o}{.}\PYG{n}{index} \PYG{o}{=} \PYG{n}{channels\PYGZus{}to\PYGZus{}pick\PYGZus{}topo}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} TOPOPLOT | Block 12}

\PYG{c+c1}{\PYGZsh{} define sleep\PYGZus{}stages}
\PYG{n}{sleep\PYGZus{}stages} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{REM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} EXPONENT TOPO}

\PYG{c+c1}{\PYGZsh{} loop over sleep stages and plot the data\PYGZsh{} Create a 3\PYGZhy{}D array}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sleep\PYGZus{}stages}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{vmax} \PYG{o}{=} \PYG{n}{Exponent\PYGZus{}vals}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{vmin} \PYG{o}{=} \PYG{n}{Exponent\PYGZus{}vals}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{stage} \PYG{o}{=} \PYG{n}{sleep\PYGZus{}stages}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        \PYG{n}{yasa}\PYG{o}{.}\PYG{n}{topoplot}\PYG{p}{(}\PYG{n}{Exponent\PYGZus{}vals}\PYG{p}{[}\PYG{n}{stage}\PYG{p}{]}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=}\PYG{n}{stage}\PYG{p}{,}
          \PYG{n}{vmin}\PYG{o}{=} \PYG{n}{vmin}\PYG{p}{,}
          \PYG{n}{vmax}\PYG{o}{=} \PYG{n}{vmax}\PYG{p}{,}
          \PYG{n}{cmap} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{coolwarm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
          \PYG{n}{n\PYGZus{}colors}\PYG{o}{=} \PYG{l+m+mi}{10} \PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}adjusts layout of plot}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/Topoplots/}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Exponent\PYGZus{}allsubs\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{stage} \PYG{p}{,} \PYG{n}{facecolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} OFFSET TOPO}

\PYG{c+c1}{\PYGZsh{} loop over sleep stages and plot the data}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sleep\PYGZus{}stages}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{vmax} \PYG{o}{=} \PYG{n}{Offset\PYGZus{}vals}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{vmin} \PYG{o}{=} \PYG{n}{Offset\PYGZus{}vals}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{stage} \PYG{o}{=} \PYG{n}{sleep\PYGZus{}stages}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        \PYG{n}{yasa}\PYG{o}{.}\PYG{n}{topoplot}\PYG{p}{(}\PYG{n}{Offset\PYGZus{}vals}\PYG{p}{[}\PYG{n}{stage}\PYG{p}{]}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=}\PYG{n}{stage}\PYG{p}{,}
          \PYG{n}{vmin}\PYG{o}{=} \PYG{n}{vmin}\PYG{p}{,}
          \PYG{n}{vmax}\PYG{o}{=} \PYG{n}{vmax}\PYG{p}{,}
          \PYG{n}{cmap} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{coolwarm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
          \PYG{n}{n\PYGZus{}colors}\PYG{o}{=} \PYG{l+m+mi}{10} \PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}adjusts layout of plot}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/Topoplots/}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Offset\PYGZus{}allsubs\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{stage} \PYG{p}{,} \PYG{n}{facecolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{b. Scatter Plotting}
\label{\detokenize{code:b-scatter-plotting}}
\sphinxAtStartPar
The following code blocks demonstrate the visualization of the aperiodic parameters using scatter plots. These plots represent the relationship between the \sphinxcode{\sphinxupquote{Offset}} and \sphinxcode{\sphinxupquote{Exponent}} values across sleepstages and channels.

\sphinxAtStartPar
\sphinxstylestrong{Scatter Plot (Block 13)}

\sphinxAtStartPar
The code creates a scatter plot by plotting \sphinxcode{\sphinxupquote{Offset}} values on the x\sphinxhyphen{}axis and \sphinxcode{\sphinxupquote{Exponent}} values on the y\sphinxhyphen{}axis. The plot represents the general distribution of the aperiodic parameters. The x and y axes are labeled appropriately, and the plot is given a title. Finally, the plot is displayed and saved as an image file.

\sphinxAtStartPar
\sphinxstylestrong{Scatter Plot with Regression Line (Block 14)}

\sphinxAtStartPar
In addition to the scatter plot, the code creates a scatter plot with a regression line using the Seaborn library. The regression line represents the overall trend in the relationship between \sphinxcode{\sphinxupquote{Offset}} and \sphinxcode{\sphinxupquote{Exponent}} values. The plot is displayed and saved as an image file for further reference.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{}  Finally, we can plot aperiodic parameters | Block 13}

\PYG{n}{Exp} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Exponent}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{Offs} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Scatter plot}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{Offs}\PYG{p}{,} \PYG{n}{Exp}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Exponent}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Aperiodic Parameters}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/results/}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Aperiodic\PYGZus{}params}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{facecolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} Scatter plot with regression line | Block 14}

\PYG{n}{sb}\PYG{o}{.}\PYG{n}{regplot}\PYG{p}{(}\PYG{n}{data} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=} \PYG{n}{Offs}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=} \PYG{n}{Exp}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/results/}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Aperiodic\PYGZus{}params\PYGZus{}reg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{facecolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Results}
\label{\detokenize{result:results}}\label{\detokenize{result::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Spectral Slope}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Average slope value increased through NREM sleep stages.

\item {} 
\sphinxAtStartPar
Average slope value oberved to be highest in N3 state.

\item {} 
\sphinxAtStartPar
REM sleep state closely resembles wake sleep state, both presenting the lowest slope values.

\item {} 
\sphinxAtStartPar
Average slope value observed to be relatively lower in meditators compared to controls

\end{itemize}

\noindent{\hspace*{\fill}\sphinxincludegraphics[scale=0.6]{{exponent}.jpg}\hspace*{\fill}}

\sphinxAtStartPar
\sphinxstylestrong{Intercept}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Intercept and Exponent were found to be positively correlated.

\item {} 
\sphinxAtStartPar
Lowest intercept values observed in wake state and highest in N3 state.

\item {} 
\sphinxAtStartPar
Intercept values observed to be relatively lower in meditators compared to controls

\end{itemize}

\noindent{\hspace*{\fill}\sphinxincludegraphics[scale=0.6]{{offset}.jpg}\hspace*{\fill}}

\sphinxAtStartPar
\sphinxstylestrong{Topography}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Average spectral slope value observed to be the lowest in the central recording regions.

\item {} 
\sphinxAtStartPar
Intercept observed to be relatively higher in the anterior recording regions and lowest in the central recording regions.

\end{itemize}


\chapter{Walk\sphinxhyphen{}through script}
\label{\detokenize{walk-through_script:walk-through-script}}\label{\detokenize{walk-through_script::doc}}
\sphinxAtStartPar
Here is a script which will walk you through the process of computing aperiodic component of Sleep EEG data. It follows the same approach as the main code script. Any details about the codes used can be referred to the \sphinxstyleemphasis{Code Script} section. This script computes for a single PSG file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}


\chapter{Miscellaneous Scripts}
\label{\detokenize{miscellaneous_script:miscellaneous-scripts}}\label{\detokenize{miscellaneous_script::doc}}
\sphinxAtStartPar
Here are some scripts useful for performing tasks such as categorizing data into groups, acquiring the PSG files details, removing files by index, computing runtime of the program.

\sphinxAtStartPar
\sphinxstylestrong{Assigning Subjects to Groups: Topoplots}

\sphinxAtStartPar
Categorize subjects into Meditators and Controls.
Make Topoplots for the two groups.
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{}Import libraies | Block 0}

\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{stats} \PYG{k+kn}{import} \PYG{n}{trim\PYGZus{}mean}
\PYG{k+kn}{import} \PYG{n+nn}{yasa}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} Load files | Block 1}

\PYG{c+c1}{\PYGZsh{} load the file containing subject info}
\PYG{n}{masterfile} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Downloads/mastersheet.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} load the fil contaning compiled aperiodic paramters}
\PYG{n}{report\PYGZus{}sleepstages\PYGZus{}II} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/CSV/nk\PYGZus{}aperiodic\PYGZus{}fooof\PYGZus{}sleepdata\PYGZus{}.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} Assign category to subjects | Block 1}

\PYG{c+c1}{\PYGZsh{} filenames}
\PYG{n}{filenames} \PYG{o}{=} \PYG{n}{report\PYGZus{}sleepstages\PYGZus{}II}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Subject}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} group labels}
\PYG{n}{group} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{names} \PYG{o+ow}{in} \PYG{n}{filenames}\PYG{p}{:}
         \PYG{n}{names} \PYG{o}{=} \PYG{n}{names}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
         \PYG{n}{index} \PYG{o}{=} \PYG{n}{masterfile}\PYG{p}{[}\PYG{n}{masterfile}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{MappingCode}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{==} \PYG{n}{names}\PYG{p}{]}\PYG{o}{.}\PYG{n}{index}
         \PYG{n}{group}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{masterfile}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Group}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Add the group label to \PYGZsq{}report\PYGZus{}sleepstages\PYGZus{}II\PYGZsq{} dataframe}
\PYG{n}{report\PYGZus{}sleepstages\PYGZus{}II}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Group}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{k+kc}{None}  \PYG{c+c1}{\PYGZsh{} Initialize the new column with None values}

\PYG{k}{for} \PYG{n}{index}\PYG{p}{,} \PYG{n}{names} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{filenames}\PYG{p}{)}\PYG{p}{:}
         \PYG{n}{indices} \PYG{o}{=} \PYG{n}{report\PYGZus{}sleepstages\PYGZus{}II}\PYG{p}{[}\PYG{n}{report\PYGZus{}sleepstages\PYGZus{}II}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Subject}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{==} \PYG{n}{names}\PYG{p}{]}\PYG{o}{.}\PYG{n}{index}
         \PYG{n}{report\PYGZus{}sleepstages\PYGZus{}II}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{indices}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Group}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{group}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} saving to a csv file}
\PYG{n}{report\PYGZus{}sleepstages\PYGZus{}II}\PYG{o}{.}\PYG{n}{to\PYGZus{}csv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/CSV/nk\PYGZus{}aperiodic\PYGZus{}fooof\PYGZus{}sleepdata\PYGZus{}2.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{index}\PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} Averaging across epochs | Block 2}

\PYG{c+c1}{\PYGZsh{} Trimmed mean}
\PYG{c+c1}{\PYGZsh{} Define the trim percentage (here, 10\PYGZpc{})}
\PYG{n}{trim\PYGZus{}percentage} \PYG{o}{=} \PYG{l+m+mf}{0.1}

\PYG{c+c1}{\PYGZsh{}  Group by columns and calculate trimmed mean for each group}
\PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals} \PYG{o}{=} \PYG{n}{report\PYGZus{}sleepstages\PYGZus{}II}\PYG{o}{.}\PYG{n}{groupby}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Stage}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Group}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{group}\PYG{p}{:} \PYG{n}{group}\PYG{o}{.}\PYG{n}{iloc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}\PYG{o}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{trim\PYGZus{}mean}\PYG{p}{,} \PYG{n}{proportiontocut}\PYG{o}{=}\PYG{n}{trim\PYGZus{}percentage}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}reset the index to convert the grouped columns (\PYGZsq{}Channel\PYGZsq{} and \PYGZsq{}Stage\PYGZsq{}) back to regular columns}
\PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{o}{.}\PYG{n}{reset\PYGZus{}index}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Extracting the channel number from the \PYGZsq{}Channel\PYGZsq{} column}
\PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{str}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{str}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Sorting the DataFrame by \PYGZsq{}Channel\PYGZsq{} and \PYGZsq{}Stage\PYGZsq{}}
\PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{o}{.}\PYG{n}{sort\PYGZus{}values}\PYG{p}{(}\PYG{n}{by}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Stage}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ascending}\PYG{o}{=}\PYG{p}{[}\PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{o}{.}\PYG{n}{reset\PYGZus{}index}\PYG{p}{(}\PYG{n}{drop}\PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{inplace}\PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} split the dataframe into controls and meditators}
\PYG{n}{Med\PYGZus{}group} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{[}\PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Group}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{MED}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{Cnt\PYGZus{}group} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{[}\PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Group}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CNT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} Parameters for Topoplot | Block 3}

\PYG{n}{channels\PYGZus{}to\PYGZus{}pick\PYGZus{}topo} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fp1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fp2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
          \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F7}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Pz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Exponet vals}

\PYG{c+c1}{\PYGZsh{} make a 2D dataframe containing exponent vals corresponding to 19 channels for 5 sleepstages}
\PYG{n}{Exponent\PYGZus{}med} \PYG{o}{=} \PYG{n}{Med\PYGZus{}group}\PYG{o}{.}\PYG{n}{pivot}\PYG{p}{(}\PYG{n}{index}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{columns}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Stage}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{values}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Exponent}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Exponent\PYGZus{}cnt} \PYG{o}{=} \PYG{n}{Cnt\PYGZus{}group}\PYG{o}{.}\PYG{n}{pivot}\PYG{p}{(}\PYG{n}{index}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{columns}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Stage}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{values}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Exponent}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} The index MUST be the channel names for yasa}
\PYG{n}{Exponent\PYGZus{}med}\PYG{o}{.}\PYG{n}{index} \PYG{o}{=} \PYG{n}{channels\PYGZus{}to\PYGZus{}pick\PYGZus{}topo}
\PYG{n}{Exponent\PYGZus{}cnt}\PYG{o}{.}\PYG{n}{index} \PYG{o}{=} \PYG{n}{channels\PYGZus{}to\PYGZus{}pick\PYGZus{}topo}

\PYG{c+c1}{\PYGZsh{} Offset vals}

\PYG{c+c1}{\PYGZsh{} make a 2D dataframe containing offset vals corresponding to 19 channels for 5 sleepstages}
\PYG{n}{Offset\PYGZus{}med} \PYG{o}{=} \PYG{n}{Med\PYGZus{}group}\PYG{o}{.}\PYG{n}{pivot}\PYG{p}{(}\PYG{n}{index}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{columns}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Stage}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{values}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Offset\PYGZus{}cnt} \PYG{o}{=} \PYG{n}{Cnt\PYGZus{}group}\PYG{o}{.}\PYG{n}{pivot}\PYG{p}{(}\PYG{n}{index}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{columns}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Stage}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{values}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} The index MUST be the channel names for yasa}
\PYG{n}{Offset\PYGZus{}med}\PYG{o}{.}\PYG{n}{index} \PYG{o}{=} \PYG{n}{channels\PYGZus{}to\PYGZus{}pick\PYGZus{}topo}
\PYG{n}{Offset\PYGZus{}cnt}\PYG{o}{.}\PYG{n}{index} \PYG{o}{=} \PYG{n}{channels\PYGZus{}to\PYGZus{}pick\PYGZus{}topo}

\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} TOPOPLOT | Block 4}

\PYG{c+c1}{\PYGZsh{}define sleep\PYGZus{}stages}
\PYG{n}{sleep\PYGZus{}stages} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{REM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} MEDITATORS}

\PYG{c+c1}{\PYGZsh{}EXPONENT TOPO}
\PYG{c+c1}{\PYGZsh{}loop over sleep stages and plot the data\PYGZsh{} Create a 3\PYGZhy{}D array}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sleep\PYGZus{}stages}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
         \PYG{n}{vmax} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Exponent}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}
         \PYG{n}{vmin} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Exponent}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}
         \PYG{n}{stage} \PYG{o}{=} \PYG{n}{sleep\PYGZus{}stages}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
         \PYG{n}{yasa}\PYG{o}{.}\PYG{n}{topoplot}\PYG{p}{(}\PYG{n}{Exponent\PYGZus{}med}\PYG{p}{[}\PYG{n}{stage}\PYG{p}{]}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=}\PYG{n}{stage}\PYG{p}{,}
                                                \PYG{n}{vmin}\PYG{o}{=} \PYG{n}{vmin}\PYG{p}{,}
                                                \PYG{n}{vmax}\PYG{o}{=} \PYG{n}{vmax}\PYG{p}{,}
                                                \PYG{n}{cmap} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{coolwarm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                                \PYG{n}{n\PYGZus{}colors}\PYG{o}{=} \PYG{l+m+mi}{10} \PYG{p}{)}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}adjusts layout of plot}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/Topoplots/}\PYG{l+s+s1}{\PYGZsq{}}
                                         \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Exponent\PYGZus{}MED\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{stage} \PYG{p}{,} \PYG{n}{facecolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}OFFSET TOPO}
\PYG{c+c1}{\PYGZsh{}loop over sleep stages and plot the data}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sleep\PYGZus{}stages}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
         \PYG{n}{vmax} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}
         \PYG{n}{vmin} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}
         \PYG{n}{stage} \PYG{o}{=} \PYG{n}{sleep\PYGZus{}stages}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
         \PYG{n}{yasa}\PYG{o}{.}\PYG{n}{topoplot}\PYG{p}{(}\PYG{n}{Offset\PYGZus{}med}\PYG{p}{[}\PYG{n}{stage}\PYG{p}{]}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=}\PYG{n}{stage}\PYG{p}{,}
                                                \PYG{n}{vmin}\PYG{o}{=} \PYG{n}{vmin}\PYG{p}{,}
                                                \PYG{n}{vmax}\PYG{o}{=} \PYG{n}{vmax}\PYG{p}{,}
                                                \PYG{n}{cmap} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{coolwarm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                                \PYG{n}{n\PYGZus{}colors}\PYG{o}{=} \PYG{l+m+mi}{10} \PYG{p}{)}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}adjusts layout of plot}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/Topoplots/}\PYG{l+s+s1}{\PYGZsq{}}
                                         \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Offset\PYGZus{}MED\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{stage} \PYG{p}{,} \PYG{n}{facecolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} CONTROLS}

\PYG{c+c1}{\PYGZsh{}EXPONENT TOPO}
\PYG{c+c1}{\PYGZsh{}loop over sleep stages and plot the data\PYGZsh{} Create a 3\PYGZhy{}D array}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sleep\PYGZus{}stages}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
         \PYG{n}{vmax} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Exponent}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}
         \PYG{n}{vmin} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Exponent}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}
         \PYG{n}{stage} \PYG{o}{=} \PYG{n}{sleep\PYGZus{}stages}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
         \PYG{n}{yasa}\PYG{o}{.}\PYG{n}{topoplot}\PYG{p}{(}\PYG{n}{Exponent\PYGZus{}cnt}\PYG{p}{[}\PYG{n}{stage}\PYG{p}{]}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=}\PYG{n}{stage}\PYG{p}{,}
                                                \PYG{n}{vmin}\PYG{o}{=} \PYG{n}{vmin}\PYG{p}{,}
                                                \PYG{n}{vmax}\PYG{o}{=} \PYG{n}{vmax}\PYG{p}{,}
                                                \PYG{n}{cmap} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{coolwarm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                                \PYG{n}{n\PYGZus{}colors}\PYG{o}{=} \PYG{l+m+mi}{10} \PYG{p}{)}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}adjusts layout of plot}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/Topoplots/}\PYG{l+s+s1}{\PYGZsq{}}
                                         \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Exponent\PYGZus{}CNT\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{stage} \PYG{p}{,} \PYG{n}{facecolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}OFFSET TOPO}
\PYG{c+c1}{\PYGZsh{}loop over sleep stages and plot the data}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sleep\PYGZus{}stages}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
         \PYG{n}{vmax} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}
         \PYG{n}{vmin} \PYG{o}{=} \PYG{n}{Channel\PYGZus{}avg\PYGZus{}vals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Offset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}
         \PYG{n}{stage} \PYG{o}{=} \PYG{n}{sleep\PYGZus{}stages}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
         \PYG{n}{yasa}\PYG{o}{.}\PYG{n}{topoplot}\PYG{p}{(}\PYG{n}{Offset\PYGZus{}cnt}\PYG{p}{[}\PYG{n}{stage}\PYG{p}{]}\PYG{p}{,} \PYG{n}{title} \PYG{o}{=}\PYG{n}{stage}\PYG{p}{,}
                                                \PYG{n}{vmin}\PYG{o}{=} \PYG{n}{vmin}\PYG{p}{,}
                                                \PYG{n}{vmax}\PYG{o}{=} \PYG{n}{vmax}\PYG{p}{,}
                                                \PYG{n}{cmap} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{coolwarm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                                \PYG{n}{n\PYGZus{}colors}\PYG{o}{=} \PYG{l+m+mi}{10} \PYG{p}{)}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}adjusts layout of plot}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/Topoplots/}\PYG{l+s+s1}{\PYGZsq{}}
                                         \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Offset\PYGZus{}CNT\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{stage} \PYG{p}{,} \PYG{n}{facecolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
         \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{PSG file details}

\sphinxAtStartPar
Access PSGfile properties.
Dataframe: channels. srate and psgfilename for each subject.
Sort files and remove files with srate != 500.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} Load files}

\PYG{c+c1}{\PYGZsh{} specify folderpath}
\PYG{n}{folder\PYGZus{}path\PYGZus{}psg} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/serverdata/ccshome/nandanik/Documents/FOOOF\PYGZus{}data/data}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{file\PYGZus{}pattern\PYGZus{}psg} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*.edf}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} List containing files names}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{chdir}\PYG{p}{(}\PYG{n}{folder\PYGZus{}path\PYGZus{}psg}\PYG{p}{)}
\PYG{n}{psg\PYGZus{}files} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{gb}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(} \PYG{n}{file\PYGZus{}pattern\PYGZus{}psg}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} extract file properties}
\PYG{n}{n\PYGZus{}channel}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{channel\PYGZus{}names}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{sfreq\PYGZus{}n}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{files} \PYG{o+ow}{in} \PYG{n}{psg\PYGZus{}files}\PYG{p}{:}

         \PYG{n}{edfdata} \PYG{o}{=} \PYG{n}{mne}\PYG{o}{.}\PYG{n}{io}\PYG{o}{.}\PYG{n}{read\PYGZus{}raw\PYGZus{}edf}\PYG{p}{(}\PYG{n}{files}\PYG{p}{,} \PYG{n}{preload}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
         \PYG{n}{srate} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{edfdata}\PYG{o}{.}\PYG{n}{info}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sfreq}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

         \PYG{n}{channels\PYGZus{}to\PYGZus{}pick} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fp1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FP1}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG Fp1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG FP1}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fp2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FP2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG Fp2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG FP2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
          \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG F3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG F4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG C3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG C4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG P3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
          \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG P4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG O1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG O2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F7}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG F7}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG F8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG T3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
          \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG T4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FZ}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG Fz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG FZ}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CZ}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG Cz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG CZ}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
          \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Pz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PZ}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG Pz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG PZ}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A2}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG A1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EEG A2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

         \PYG{n}{edfdata}\PYG{o}{.}\PYG{n}{pick\PYGZus{}channels}\PYG{p}{(}\PYG{n}{channels\PYGZus{}to\PYGZus{}pick}\PYG{p}{)}

         \PYG{n}{num} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{edfdata}\PYG{o}{.}\PYG{n}{ch\PYGZus{}names}\PYG{p}{)}
         \PYG{n}{n\PYGZus{}channel}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{num}\PYG{p}{)}

         \PYG{n}{name} \PYG{o}{=} \PYG{n}{edfdata}\PYG{o}{.}\PYG{n}{ch\PYGZus{}names}
         \PYG{n}{channel\PYGZus{}names}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}

         \PYG{n}{sfreq}\PYG{o}{=} \PYG{n}{edfdata}\PYG{o}{.}\PYG{n}{info}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sfreq}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
         \PYG{n}{sfreq\PYGZus{}n}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{sfreq}\PYG{p}{)}


\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Total files processed:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{psg\PYGZus{}files}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Total entries in n\PYGZus{}channel:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{n\PYGZus{}channel}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} dataframe}
\PYG{n}{psg\PYGZus{}channel}\PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{file}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{psg\PYGZus{}files}\PYG{p}{,}
                          \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n\PYGZus{}channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{n\PYGZus{}channel}\PYG{p}{,}
                          \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{channels}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{channel\PYGZus{}names}\PYG{p}{,}
                          \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sfreq}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{sfreq\PYGZus{}n}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} files with different sampling frequencies}
\PYG{n}{count1} \PYG{o}{=} \PYG{p}{(}\PYG{n}{psg\PYGZus{}channel}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sfreq}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{200}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{count2} \PYG{o}{=} \PYG{p}{(}\PYG{n}{psg\PYGZus{}channel}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sfreq}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{500}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{count3} \PYG{o}{=} \PYG{p}{(}\PYG{n}{psg\PYGZus{}channel}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n\PYGZus{}channel}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{19}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} files to be deleted}
\PYG{n}{delete\PYGZus{}files}\PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{delete\PYGZus{}files}\PYG{o}{=} \PYG{n}{delete\PYGZus{}files}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{psg\PYGZus{}channel}\PYG{p}{[}\PYG{n}{psg\PYGZus{}channel}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sfreq}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{!=}\PYG{l+m+mi}{500}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} files to be kept}
\PYG{n}{valid\PYGZus{}files}\PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{valid\PYGZus{}files}\PYG{o}{=} \PYG{n}{valid\PYGZus{}files}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{psg\PYGZus{}channel}\PYG{p}{[}\PYG{n}{psg\PYGZus{}channel}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sfreq}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{l+m+mi}{500}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZpc{}\PYGZpc{} plotting data}
\PYG{n}{edfdata} \PYG{o}{=} \PYG{n}{mne}\PYG{o}{.}\PYG{n}{io}\PYG{o}{.}\PYG{n}{read\PYGZus{}raw\PYGZus{}edf}\PYG{p}{(}\PYG{n}{files}\PYG{p}{,} \PYG{n}{preload}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{n}{edfdata}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kc}{None}\PYG{p}{,}\PYG{n}{fir\PYGZus{}design}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{firwin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{load\PYGZus{}data}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{edfdata}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{k+kc}{None}\PYG{p}{,}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{n}{fir\PYGZus{}design}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{firwin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{load\PYGZus{}data}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{edfdata}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Remove unwanted PSG files by index}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Indices of files to remove}
\PYG{n}{psg\PYGZus{}del} \PYG{o}{=} \PYG{p}{[} \PYG{n}{index1}\PYG{p}{,} \PYG{n}{index2}\PYG{p}{,} \PYG{n}{index3}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}remove unwanted psg files}
\PYG{n}{psg\PYGZus{}files\PYGZus{}all} \PYG{o}{=} \PYG{p}{[}\PYG{n}{x} \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{psg\PYGZus{}files\PYGZus{}all}\PYG{p}{)} \PYG{k}{if} \PYG{n}{i} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{psg\PYGZus{}del}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Indices of files to remove}
\PYG{n}{scored\PYGZus{}del} \PYG{o}{=} \PYG{p}{[}\PYG{n}{index1}\PYG{p}{,} \PYG{n}{index2}\PYG{p}{,} \PYG{n}{index3}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}remove unwanted scored files}
\PYG{n}{scored\PYGZus{}files\PYGZus{}all} \PYG{o}{=} \PYG{p}{[}\PYG{n}{x} \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{scored\PYGZus{}files\PYGZus{}all}\PYG{p}{)} \PYG{k}{if} \PYG{n}{i} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{scored\PYGZus{}del}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Program Runtime}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{time}

\PYG{n}{start\PYGZus{}time} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} this is where your loop goes}

\PYG{n}{end\PYGZus{}time} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{duration} \PYG{o}{=} \PYG{n}{end\PYGZus{}time} \PYG{o}{\PYGZhy{}} \PYG{n}{start\PYGZus{}time}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Loop duration:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{duration}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{seconds}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Summaries}
\label{\detokenize{summary:summaries}}\label{\detokenize{summary::doc}}

\section{Scale\sphinxhyphen{}free and oscillatory spectral measures of sleep stages in humans (Schneider et. al. 2022)}
\label{\detokenize{summary:scale-free-and-oscillatory-spectral-measures-of-sleep-stages-in-humans-schneider-et-al-2022}}
\sphinxAtStartPar
\sphinxhref{https://www.frontiersin.org/articles/10.3389/fninf.2022.989262/full}{Research Paper}

\sphinxAtStartPar
\sphinxstylestrong{Motivation\sphinxhyphen{}}

\sphinxAtStartPar
The paper intends to investigate the scale\sphinxhyphen{}free and oscillatory characteristics of sleep stages in humans. It explores the spectral measures associated with different sleep stages and aims to understand the neurophysiological basis of it.

\sphinxAtStartPar
\sphinxstylestrong{Source data\sphinxhyphen{}}

\sphinxAtStartPar
The Budapest\sphinxhyphen{}Munich database of sleep records comprises whole night PSG Data collected from 251 healthy subjects, their age ranging from 4 to 69 years. Subjects were divided into 4 age groups \sphinxhyphen{} children (4\textendash{}10 years, N =31), teenagers (10\textendash{}20 years, N = 36), young adults (20\textendash{}40 years, N = 150), and middle\sphinxhyphen{}aged adults (40\textendash{}69 years, N= 34) (Bódizs et al., 2021a)

\sphinxAtStartPar
\sphinxstylestrong{Methodology\sphinxhyphen{}}

\sphinxAtStartPar
{[}A{]}. PSD Calculation :
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
EEG signals were divided using 4s sliding window while employing 50\% overlap(2s step).

\item {} 
\sphinxAtStartPar
Windows containing artifacts were rejected.

\item {} 
\sphinxAtStartPar
Each window was Hanning tapered.

\item {} 
\sphinxAtStartPar
FFT was applied to these tapered windows using mix\sphinxhyphen{}radix procedure, a variant of FFT algorithm suitable for windows of arbitrary length.

\item {} 
\sphinxAtStartPar
Welch’s method was applied to obtain the average power\sphinxhyphen{}spectral density.

\end{enumerate}

\sphinxAtStartPar
{[}B{]}. Model fitting : The authors have used the “fitting oscillations and one over f” (FOOOF) method to extract parameters from the power spectra.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
A first approximation of the aperiodic component is calculated using a power\sphinxhyphen{}law equation, which is then subtracted from the original spectrum to obtain a flattened version of the spectrum.

\item {} 
\sphinxAtStartPar
The flattened spectrum is analyzed to identify and fit Gaussian functions that represent the periodic components (spectral peaks). These Gaussians are iteratively fitted and subtracted from the flattened spectrum.

\item {} 
\sphinxAtStartPar
The total periodic component is removed from the original spectrum, resulting in a peak\sphinxhyphen{}removed spectrum.

\item {} 
\sphinxAtStartPar
The aperiodic component is fitted again to the peak\sphinxhyphen{}removed spectrum.

\item {} 
\sphinxAtStartPar
The final result is a combination of the fitted aperiodic and periodic components.

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[scale=0.4]{{model_fit}.png}\hspace*{\fill}}

\sphinxAtStartPar
\sphinxstyleemphasis{Schneider et. al. 2022}

\sphinxAtStartPar
{[}C{]}. Parameter Extraction : Several parameters were selected for analysis from the fitted spectra, which are : spectral slope, center frequency, power of the spectral peak with the highest power. The analysis included an alternative spectral intercept, which is determined as the intersection of the fitted power\sphinxhyphen{}law at the frequency of the largest oscillatory peak.

\sphinxAtStartPar
The extracted spectral parameters were analyzed using ‘repeated measures ANOVA
with sigma restricted parametrization’. The analysis included these categorical factors\sphinxhyphen{} Sex(M/F), Age group(4), Sleep stages(W, N1, N2, N3, REM), Brain region, Laterality.

\sphinxAtStartPar
\sphinxstylestrong{Results\sphinxhyphen{}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Spectral slope:

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Average slope value reported highest in the wake state

\item {} 
\sphinxAtStartPar
Average slope value decreased through NREM sleep stages

\item {} 
\sphinxAtStartPar
Steeper slopes reported in younger subjects

\item {} 
\sphinxAtStartPar
Steeper slopes in anterior recording regions

\item {} 
\sphinxAtStartPar
Spectral slope value depicted increase with ageof subjects.

\end{itemize}

\noindent{\hspace*{\fill}\sphinxincludegraphics{{spectral_slope}.png}\hspace*{\fill}}

\sphinxAtStartPar
\sphinxstyleemphasis{Schneider et. al. 2022}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Intercept:

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Alternative intercept measure was adopted, calculated at frequency of largest peak

\item {} 
\sphinxAtStartPar
Significant sleep stage main effect {[}F(4,836) = 35.73, p \textless{} 0.00001, η2p = 0.15{]} indicating increased intercepts in the slow\sphinxhyphen{}wave sleep stages

\item {} 
\sphinxAtStartPar
Age main effect {[}F(3,209) = 26.37, η2p = 0.27{]}, with the intercept being higher in children.

\item {} 
\sphinxAtStartPar
Stage\sphinxhyphen{}region interaction was observed {[}F(16,3344) = 9.18, p \textless{} 0.00001, η2p = 0.04{]}. The increase in intercepts was more pronounced in the frontopolar and frontal regions.

\end{itemize}

\noindent{\hspace*{\fill}\sphinxincludegraphics{{intercept}.png}\hspace*{\fill}}

\sphinxAtStartPar
\sphinxstyleemphasis{Schneider et. al. 2022}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Peak Central Frequency:

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
The central frequency of the peak with the highest power was increased in the frontal and frontopolar regions.

\item {} 
\sphinxAtStartPar
A significant main effect of region {[}F(4,824) = 58.138, p \textless{} 0.00001, η2p = 0.22{]}, indicating differences in central frequencies across brain regions.

\item {} 
\sphinxAtStartPar
Dominant peak frequencies converged to characteristic sleep spindle frequency in NREM2 stage, most consistent in teenagers.

\item {} 
\sphinxAtStartPar
Increased theta activity observed in NREM1 due to changes in aperiodic component, but the dominant peaks resulted from alpha oscillations (Riedner et al., 2016; Cakan et al., 2022).

\end{itemize}

\noindent{\hspace*{\fill}\sphinxincludegraphics{{center_freq}.png}\hspace*{\fill}}

\sphinxAtStartPar
\sphinxstyleemphasis{Schneider et. al. 2022}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
Peak power:

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Significant main effects of sleep stage {[}F(4,824) = 88.765, p \textless{} 0.00001, η\textasciicircum{}2p = 0.301{]}and brain region {[}F(4,824) = 97.645, p \textless{} 0.00001, η\textasciicircum{}2p =0.321{]} were found for the power of the strongest spectral peak

\item {} 
\sphinxAtStartPar
Peak power exhibits prominence in NREM2 stage in younger adults and declines with age.

\end{itemize}

\noindent{\hspace*{\fill}\sphinxincludegraphics{{pk_power}.png}\hspace*{\fill}}

\sphinxAtStartPar
\sphinxstyleemphasis{Schneider et. al. 2022}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
\sphinxAtStartPar
Adjusted Spectral slope:

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
To obtain subject\sphinxhyphen{}independent measure, by subtracting wake stage slope from other stages of individual subjects.

\item {} 
\sphinxAtStartPar
Exhibits stronger sleep stage main effect and stage\sphinxhyphen{}region interaction.

\end{itemize}

\noindent{\hspace*{\fill}\sphinxincludegraphics{{adj_slope}.png}\hspace*{\fill}}

\sphinxAtStartPar
\sphinxstyleemphasis{Schneider et. al. 2022}

\sphinxAtStartPar
\sphinxstylestrong{Discussions\sphinxhyphen{}}

\sphinxAtStartPar
The spectral slope proved to be a strong indicator of sleep stages. The EEG spectral slopes suggest that wakefulness exhibits antipersistent Brownian motion, while sleep is characterized by persistent Brownian motion. State\sphinxhyphen{}specific values were adjusted by normalizing them against wakefulness\sphinxhyphen{}derived values, leading to even more reliable findings than using absolute values. Sleep stages exhibited a fine\sphinxhyphen{}tuned decrease in exponent relative to wakefulness, from \sphinxhyphen{}0.2 to \sphinxhyphen{}1 in NREM1 and SWS stages.

\sphinxAtStartPar
The findings not only confirm the effects of sleep stages on EEG spectral slopes but also support the age and region dependency previously reported in studies (Voytek et al., 2015; Bódizs et al., 2021b; Pathania et al., 2022). Steeper spectra was a notable feature in younger subjects and in more anterior regions of brain. The most significant age\sphinxhyphen{}related flattening of EEG spectral slopes was observed in SWS, and antero\sphinxhyphen{}posterior differences in spectral steepness were particularly prominent in this stage. Additionally, the findings suggested that the alternative and adaptive spectral intercept is independent of the slope, providing non\sphinxhyphen{}redundant sleep stage effects when analyzing these intercepts.

\sphinxAtStartPar
Central peak frequencies in EEG reflected neural oscillatory patterns specific to different sleep stages. Alpha activity (8\sphinxhyphen{}12 Hz) observed in resting wakefulness, sleep spindles (11\sphinxhyphen{}16 Hz) in NREM sleep stages including SWS, and theta (4\sphinxhyphen{}8 Hz) or beta (16\sphinxhyphen{}30 Hz) in REM sleep. Stable wake state alpha frequency observed in children. NREM2 and SWS stages exhibit prominent sleep spindle frequencies with antero\sphinxhyphen{}posterior differences, while NREM1 and REM sleep show beta oscillations with anterior predominance.

\sphinxAtStartPar
The study found that high peak power values are characteristic of wakefulness and NREM2 sleep, lowest in NREM1 and REM, and intermediate in SWS.These findings align with known patterns of alpha and sleep spindle oscillations. Age\sphinxhyphen{}related changes in peak power indicate an initial increase in sleep spindle frequencies during teenage/young adult years, followed by a decrease in middle\sphinxhyphen{}aged adults.

\sphinxAtStartPar
However, the study has limitations, such as missing age ranges, differences in sleep scoring rules, and assumptions about Gaussian spectral peaks.Despite these limitations, the results suggest that spectral parameters can serve as objective measures for characterizing sleep states, potentially enabling automated sleep evaluation.


\section{Compute the average bandpower of an EEG signal (Raphael Vallet)}
\label{\detokenize{summary:compute-the-average-bandpower-of-an-eeg-signal-raphael-vallet}}
\sphinxAtStartPar
\sphinxhref{https://raphaelvallat.com/bandpower.html}{Tutorial link}

\sphinxAtStartPar
The tutorial demonstrates how to compute the average band power of an EEG signal in a specific frequency range using Python. The tutorial talks about Welch’s periodogram method and the multitaper spectral estimation method of EEG signal processing.

\sphinxAtStartPar
The flow of the code is as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Import necessary libraries: NumPy, SciPy, SciPy. Integrate, matplotlib, seaborn

\item {} 
\sphinxAtStartPar
Load EEG Data

\item {} 
\sphinxAtStartPar
Define parameter: sample rate, time

\item {} 
\sphinxAtStartPar
Plot the signal

\item {} 
\sphinxAtStartPar
Compute power spectral density using Welch’s method

\item {} 
\sphinxAtStartPar
Compute average delta band power using Simpson’s rule

\item {} 
\sphinxAtStartPar
Compute relative band power

\end{enumerate}

\sphinxAtStartPar
The tutorial uses the following concepts and methodologies:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{FFT:} FFT is a mathematical tool which decomposes a signal into its constituent frequencies. It represents a signal in the frequency domain.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Power Spectral Density:} PSD is given by the magnitude squared of Fourier transform. It provides information about the strength of the constituent frequencies in the signal.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Welch’s Periodogram:} Welch’s periodogram estimates the PSD of a signal. Welch’s method improves the accuracy of the classic periodogram in EEG signal processing. It does so by dividing the data into shorter segments, computing separate periodograms for each segment, and averaging them. This accounts for the time\sphinxhyphen{}varying nature of EEG signals and reduces bias and variance, resulting in a more reliable spectral analysis. However, this method comes at the cost of low frequency resolution.

\end{enumerate}

\sphinxAtStartPar
\sphinxstyleemphasis{Frequency resolution}: Fres = 1/t = 1/30 = 0.033 (t= time duration of signal)

\sphinxAtStartPar
\sphinxstyleemphasis{Optimal window duration} = 2/ lowest freq. of interest = 2/0.5 = 4s (for delta freq)

\sphinxAtStartPar
\sphinxstyleemphasis{Note:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
The only thing that increases frequency resolution is time. Changes in sampling frequency do not increase the frequency resolution but only the frequency coverage.

\item {} 
\sphinxAtStartPar
The maximum value of the x\sphinxhyphen{}axis of a Welch’s Periodogram is always half the sampling frequency of the original signal.

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Simpson’s Rule:} It’s an integration method used to approximate the area under the curve. The area can be decomposed into several parabola and then summed up. Here, it has been used for integrating the psd values within the range of a frequency band to estimate average band power.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Multitaper Method:} This method was developed to overcome the limitations of classical spectral estimation techniques. It combines the advantages of classical and Welch’s periodograms to provide better spectral estimation with high frequency resolution and low variance. The method involves filtering the signal with optimal bandpass filters known as Slepian sequences, calculating a periodogram for each filtered data, and averaging the results. However, this method is computationally intensive and hence much slower than Welch’s method.

\end{enumerate}


\section{FOOF Documentation}
\label{\detokenize{summary:foof-documentation}}
\sphinxAtStartPar
\sphinxhref{https://fooof-tools.github.io/fooof/}{Documentation site}

\sphinxAtStartPar
FOOOF is a tool for parameterizing neural power spectra. It models the power spectrum as a combination of an aperiodic component (1/f slope) and periodic components (peaks over the 1/f slope).

\sphinxAtStartPar
The benefit of using FOOOF is that it characterizes the peaks in the power spectrum in terms of their center frequency, power, and bandwidth without the need to predefine specific bands of interest for the aperiodic component. It also provides a measure of the aperiodic component itself.

\sphinxAtStartPar
FOOOF is written in python and is object\sphinxhyphen{}oriented.There is a Matlab wrapper that allows you to use FOOOF from Matlab.

\sphinxAtStartPar
FOOOF works on frequency representations of power spectra in linear space. FOOFGroup can be used to fit a group of power spectra
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
To fit a single power spectra \sphinxhyphen{}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Import the FOOOF object}
\PYG{k+kn}{from} \PYG{n+nn}{fooof} \PYG{k+kn}{import} \PYG{n}{FOOOF}

\PYG{c+c1}{\PYGZsh{} Initialize FOOOF object}
\PYG{n}{fm} \PYG{o}{=} \PYG{n}{FOOOF}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define frequency range across which to model the spectrum}
\PYG{n}{freq\PYGZus{}range} \PYG{o}{=} \PYG{p}{[}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Model the power spectrum with FOOOF, and print out a report}
\PYG{n}{fm}\PYG{o}{.}\PYG{n}{report}\PYG{p}{(}\PYG{n}{freqs}\PYG{p}{,} \PYG{n}{spectrum}\PYG{p}{,} \PYG{n}{freq\PYGZus{}range}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
FOOOF has settings for the algorithm \sphinxhyphen{}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Initialize a FOOOF model object with defined settings}
\PYG{n}{fm} \PYG{o}{=} \PYG{n}{FOOOF}\PYG{p}{(}\PYG{n}{peak\PYGZus{}width\PYGZus{}limits}\PYG{o}{=}\PYG{p}{[}\PYG{n}{z}\PYG{p}{,} \PYG{n}{w}\PYG{p}{]}\PYG{p}{,} \PYG{n}{max\PYGZus{}n\PYGZus{}peaks}\PYG{o}{=}\PYG{n}{a}\PYG{p}{,} \PYG{n}{min\PYGZus{}peak\PYGZus{}height}\PYG{o}{=}\PYG{n}{g}\PYG{p}{,}
\PYG{n}{peak\PYGZus{}threshold}\PYG{o}{=}\PYG{n}{b} \PYG{p}{,} \PYG{n}{aperiodic\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fixed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
To fit a group of Spectra \sphinxhyphen{}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Import FOOOFGroup}
\PYG{k+kn}{from} \PYG{n+nn}{fooof} \PYG{k+kn}{import} \PYG{n}{FOOOFGroup}

\PYG{c+c1}{\PYGZsh{} Initialize FOOOFGroup object}
\PYG{n}{fg} \PYG{o}{=} \PYG{n}{FOOOFGroup}\PYG{p}{(}\PYG{n}{peak\PYGZus{}width\PYGZus{}limits}\PYG{o}{=}\PYG{p}{[}\PYG{n}{z}\PYG{p}{,} \PYG{n}{w}\PYG{p}{]}\PYG{p}{,} \PYG{n}{max\PYGZus{}n\PYGZus{}peaks}\PYG{o}{=}\PYG{n}{a}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Fit spectra and save results}
\PYG{n}{fg}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{freqs}\PYG{p}{,} \PYG{n}{spectra}\PYG{p}{)}
\PYG{n}{fg}\PYG{o}{.}\PYG{n}{save\PYGZus{}report}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fg}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{n}{file\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fooof\PYGZus{}group\PYGZus{}results}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{save\PYGZus{}results}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{References}
\label{\detokenize{references:references}}\label{\detokenize{references::doc}}
\sphinxAtStartPar
1.Schneider et. al. Scale\sphinxhyphen{}free and oscillatory spectral measures of sleep stages in humans. Frontiers in Neuroinformatics, 16, 2022. \sphinxhref{https://www.frontiersin.org/articles/10.3389/fninf.2022.989262/full}{Research Paper}

\sphinxAtStartPar
2.Elizabeth Landau, “Brain’s ‘Background Noise’ May Hold Clues to Persistent Mysteries”, Quantamagazine, February 8, 2021. \sphinxhref{https://www.quantamagazine.org/brains-background-noise-may-hold-clues-to-persistent-mysteries-20210208/}{Here’s the link to the article}

\sphinxAtStartPar
3.Talk by Dr. Bradley Voytek: “Non\sphinxhyphen{}Parametric Approaches to EEG Signal Analysis”, Presented at the EEG: Analytical Approaches and Applications Virtual Symposium, June 6\sphinxhyphen{}7, 2019, hosted by Sapien Labs. \sphinxhref{https://www.youtube.com/watch?v=OmTY6F0Zl2E}{Youtube link}
\sphinxcontribyoutube{https://youtu.be/}{OmTY6F0Zl2E}{}

\sphinxAtStartPar
4.Dr. Bradley Voytek’s workshop at the 2022 Annual Society for Psychophysiological Research, “Methods for analyzing neural oscillations and aperiodic activity”. \sphinxhref{https://www.youtube.com/watch?v=bRsMdtldwpQ\&list=PLVi8sLP-Ia3oa6e-sdAo1lW2hzGmad5ay}{Youtube link}
\sphinxcontribyoutube{https://youtu.be/}{bRsMdtldwpQ}{}

\sphinxAtStartPar
5.BeMoBIL Colloquial Talk by Dr. Thomas Donoghue, “Methodological Considerations for Neural Oscillations”, 2020. \sphinxhref{https://www.youtube.com/watch?v=vi9q1muqbKM}{Youtube link}
\sphinxcontribyoutube{https://youtu.be/}{vi9q1muqbKM}{}

\sphinxAtStartPar
6.Raphael Vallat. Compute the average bandpower of an EEG signal. \sphinxhref{https://raphaelvallat.com/}{Website} . \sphinxhref{https://raphaelvallat.com/bandpower.html}{Tutorial} .

\sphinxAtStartPar
7.Raphael Vallat. Yasa Topoplot tutorial. \sphinxhref{https://raphaelvallat.com/}{Website} . \sphinxhref{https://raphaelvallat.com/yasa/build/html/generated/yasa.topoplot.html}{Tutorial} .

\sphinxAtStartPar
8.FOOOF Documentation. \sphinxhref{https://fooof-tools.github.io/fooof/}{Link}



\renewcommand{\indexname}{Index}
\printindex
\end{document}